{"version":3,"file":"list-item-xb9BgIlX.js","sources":["../../node_modules/mdast-util-to-markdown/lib/util/association.js","../../node_modules/mdast-util-to-markdown/lib/util/container-flow.js","../../node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","../../node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","../../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../../node_modules/mdast-util-to-markdown/lib/util/safe.js","../../node_modules/mdast-util-to-markdown/lib/util/track.js","../../node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","../../node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","../../node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","../../node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","../../node_modules/mdast-util-to-markdown/lib/handle/list-item.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').AssociationId} AssociationId\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references don’t work in this\n * matching: `&copy;` does not match `©`, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how we’re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n","/**\n * @typedef {import('../types.js').FlowContent} FlowContent\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').TrackFields} TrackFields\n */\n\n/**\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {Node} left\n * @param {Node} right\n * @param {Parent} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n","/**\n * @typedef {import('../types.js').IndentLines} IndentLines\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n * @typedef {import('../types.js').ConstructName} ConstructName\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').SafeConfig} SafeConfig\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @typedef {import('../types.js').CreateTracker} CreateTracker\n * @typedef {import('../types.js').TrackCurrent} TrackCurrent\n * @typedef {import('../types.js').TrackMove} TrackMove\n * @typedef {import('../types.js').TrackShift} TrackShift\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n","/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {patternCompile} from '../util/pattern-compile.js'\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'tab'\n\n  // To do: remove in a major.\n  // @ts-expect-error: deprecated.\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n"],"names":["association","node","decodeString","containerFlow","parent","state","info","indexStack","children","tracker","results","index","child","between","left","right","result","eol","indentLines","value","map","start","line","match","one","patternCompile","pattern","before","patternInScope","stack","listInScope","list","none","safe","input","config","positions","infos","expression","after","position","numerical","end","escapeBackslashes","a","b","whole","track","options","now","lineShift","column","move","current","shift","chunks","tail","containerPhrasing","handle","inlineCode","inlineCodePeek","_","sequence","checkBullet","marker","checkListItemIndent","style","listItem","listItemIndent","bullet","size","exit","blank"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}