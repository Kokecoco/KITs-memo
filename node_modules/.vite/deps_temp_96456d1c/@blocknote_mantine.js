import {
  ActionIcon,
  Badge,
  Button,
  CheckIcon,
  FileInput,
  Group,
  Loader,
  LoadingOverlay,
  MantineProvider,
  Menu,
  Popover,
  PopoverDropdown,
  PopoverTarget,
  Stack,
  Tabs,
  Text,
  TextInput,
  Tooltip,
  flip,
  mergeRefs,
  offset,
  shift,
  size,
  useDismiss,
  useFloating,
  useFocusTrap,
  useFocusWithin,
  useInteractions,
  useTransitionStyles
} from "./chunk-AQK535WG.js";
import "./chunk-6PXSGDAH.js";
import {
  require_react_dom
} from "./chunk-6BKLQ22S.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  $i,
  Ar,
  Cr,
  D,
  Dr,
  Er,
  Extension,
  Fi,
  Ii,
  Ir,
  Li,
  NodeView,
  Nr,
  O,
  Plugin,
  PluginKey,
  Pr,
  Qi,
  Sr,
  Ur,
  Vi,
  Vo,
  Xi,
  at,
  isNodeSelection,
  isTextSelection,
  jr,
  le,
  posToDOMRect,
  ro,
  rt,
  so,
  st,
  to,
  z
} from "./chunk-4PPCZQRY.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@blocknote/mantine/dist/blocknote-mantine.js
var import_react5 = __toESM(require_react());

// node_modules/@blocknote/react/dist/blocknote-react.js
var import_react2 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y3 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y3,
    right: x2 + width,
    bottom: y3 + height,
    left: x2,
    x: x2,
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset3 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset3, _state$modifiersData$.centerOffset = offset3 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x2 = _ref.x, y3 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y3 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y3 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y3
  }) : {
    x: x2,
    y: y3
  };
  x2 = _ref3.x;
  y3 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y3 -= offsetY - popperRect.height;
      y3 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y3
  }, getWindow(popper2)) : {
    x: x2,
    y: y3
  };
  x2 = _ref4.x;
  y3 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y3 + "px)" : "translate3d(" + x2 + "px, " + y3 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y3 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element),
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y3 = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset3 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset3[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip2(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i3) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i3).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i2 = numberOfChecks; _i2 > 0; _i2--) {
      var _ret = _loop(_i2);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip2,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset3) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset3 === "function" ? offset3(Object.assign({}, rects, {
    placement
  })) : offset3, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset2(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset3 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset3);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y3 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y3;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset2
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset3 = popperOffsets2[mainAxis];
    var min2 = offset3 + overflow[mainSide];
    var max2 = offset3 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset3 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset3 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset3, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset3;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn3());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state = fn3({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect5 = _ref.effect;
        if (typeof effect5 === "function") {
          var cleanupFn = effect5({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/tippy.js/dist/tippy.esm.js
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce2(fn3, ms) {
  if (ms === 0) {
    return fn3;
  }
  var timeout;
  return function(arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      fn3(arg);
    }, ms);
  };
}
function removeProperties(obj, keys) {
  var clone = Object.assign({}, obj);
  keys.forEach(function(key) {
    delete clone[key];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function(item, index) {
    return arr.indexOf(item) === index;
  });
}
function getBasePlacement2(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement2(value) {
  return ["Element", "Fragment"].some(function(type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement2(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function(el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function(el) {
    if (el) {
      el.setAttribute("data-state", state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref) {
    var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement2(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method](event, listener);
  });
}
function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now = performance.now();
  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser ? (
  // @ts-ignore
  !!window.msCrypto
) : false;
function createMemoryLeakWarning(method) {
  var txt = method === "destroy" ? "n already-" : " ";
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
}
function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c👷‍ This is a development-only message. It will be removed in production.\n  ");
}
function getFormattedMessage(message) {
  return [
    getDevMessage(message),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var visitedMessages;
if (true) {
  resetVisitedMessages();
}
function resetVisitedMessages() {
  visitedMessages = /* @__PURE__ */ new Set();
}
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;
    visitedMessages.add(message);
    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;
    visitedMessages.add(message);
    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
  errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {
  },
  onBeforeUpdate: function onBeforeUpdate() {
  },
  onCreate: function onCreate() {
  },
  onDestroy: function onDestroy() {
  },
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  onUntrigger: function onUntrigger() {
  },
  onClickOutside: function onClickOutside() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  if (true) {
    validateProps(partialProps, []);
  }
  var keys = Object.keys(partialProps);
  keys.forEach(function(key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps2 = plugins.reduce(function(acc, plugin) {
    var name = plugin.name, defaultValue = plugin.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key) {
    var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference2, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference2])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var keys = Object.keys(partialProps);
  keys.forEach(function(prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function(plugin) {
        return plugin.name === prop;
      }).length === 0;
    }
    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow2 = div();
  if (value === true) {
    arrow2.className = ARROW_CLASS;
  } else {
    arrow2.className = SVG_ARROW_CLASS;
    if (isElement2(value)) {
      arrow2.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow2, value);
    }
  }
  return arrow2;
}
function setContent(content, props) {
  if (isElement2(props.content)) {
    dangerouslySetInnerHTML(content, "");
    content.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function(node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute("data-state", "hidden");
  setContent(content, instance.props);
  popper2.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow2 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent(content2, instance.props);
    }
    if (nextProps.arrow) {
      if (!arrow2) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow2);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow2) {
      box2.removeChild(arrow2);
    }
  }
  return {
    popper: popper2,
    onUpdate
  };
}
render.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce2(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id,
    reference: reference2,
    popper: div(),
    popperInstance,
    props,
    state,
    plugins,
    // methods
    clearDelayTimeouts,
    setProps,
    setContent: setContent2,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy
  };
  if (!props.render) {
    if (true) {
      errorWhen(true, "render() function has not been supplied.");
    }
    return instance;
  }
  var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance.id;
  instance.popper = popper2;
  reference2._tippy = instance;
  popper2._tippy = instance;
  var pluginsHooks = plugins.map(function(plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance;
  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id2 = popper2.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      var currentValue = node.getAttribute(attr);
      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
      } else {
        var nextValue = currentValue && currentValue.replace(id2, "").trim();
        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      if (instance.props.interactive) {
        node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
      } else {
        node.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el) {
      return actualContains(el, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc = getDocument();
    doc.addEventListener("mousedown", onDocumentPress, true);
    doc.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc = getDocument();
    doc.removeEventListener("mousedown", onDocumentPress, true);
    doc.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on3(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node,
        eventType,
        handler,
        options
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on3("touchstart", onTrigger2, {
        passive: true
      });
      on3("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on3(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on3("mouseleave", onMouseLeave);
          break;
        case "focus":
          on3(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on3("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function(_ref) {
      var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
      var _instance$popperInsta;
      var instance2 = popper3._tippy;
      var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state2) {
        return {
          popperRect: popper3.getBoundingClientRect(),
          popperState: state2,
          props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset3 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow2 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference2;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn3(_ref2) {
        var state2 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
            if (attr === "placement") {
              box.setAttribute("data-placement", state2.placement);
            } else {
              if (state2.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, "");
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state2.attributes.popper = {};
        }
      }
    };
    var modifiers = [{
      name: "offset",
      options: {
        offset: offset3
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow2) {
      modifiers.push({
        name: "arrow",
        options: {
          element: arrow2,
          padding: 3
        }
      });
    }
    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = createPopper3(computedReference, popper2, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers
    }));
  }
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode;
    var node = getCurrentTarget();
    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode = node.parentNode;
    } else {
      parentNode = invokeWithArgsOrReturn(appendTo, [node]);
    }
    if (!parentNode.contains(popper2)) {
      parentNode.appendChild(popper2);
    }
    instance.state.isMounted = true;
    createPopperInstance();
    if (true) {
      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
    }
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance.hide();
      });
    }
  }
  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    instance.hide();
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce2(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
        node.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance, partialProps]);
  }
  function setContent2(content) {
    instance.setProps({
      content
    });
  }
  function show() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
    }
    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance.state.isShown = true;
          invokeHook("onShown", [instance]);
        });
      }
    };
    mount();
  }
  function hide2() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
    }
    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  function hideWithInteractivity(event) {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
    }
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
    }
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook("onHidden", [instance]);
  }
  function destroy() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference2._tippy;
    instance.state.isDestroyed = true;
    invokeHook("onDestroy", [instance]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  if (true) {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins
  });
  var elements = getArrayOfElements(targets);
  if (true) {
    var isSingleContentElement = isElement2(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var instances = elements.reduce(function(acc, reference2) {
    var instance = reference2 && createTippy(reference2, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement2(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
var applyStylesModifier = Object.assign({}, applyStyles_default, {
  effect: function effect4(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
  }
});
tippy.setDefaultProps({
  render
});
var tippy_esm_default = tippy;

// node_modules/@tiptap/extension-bubble-menu/dist/index.js
var BubbleMenuView = class {
  constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state, from, to: to2 }) => {
      const { doc, selection } = state;
      const { empty } = selection;
      const isEmptyTextBlock = !doc.textBetween(from, to2).length && isTextSelection(state.selection);
      const isChildOfMenu = this.element.contains(document.activeElement);
      const hasEditorFocus = view2.hasFocus() || isChildOfMenu;
      if (!hasEditorFocus || empty || isEmptyTextBlock || !this.editor.isEditable) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.dragstartHandler = () => {
      this.hide();
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      this.hide();
    };
    this.tippyBlurHandler = (event) => {
      this.blurHandler({ event });
    };
    this.handleDebouncedUpdate = (view2, oldState) => {
      const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view2.state.selection));
      const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view2.state.doc));
      if (!selectionChanged && !docChanged) {
        return;
      }
      if (this.updateDebounceTimer) {
        clearTimeout(this.updateDebounceTimer);
      }
      this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(view2, selectionChanged, docChanged, oldState);
      }, this.updateDelay);
    };
    this.updateHandler = (view2, selectionChanged, docChanged, oldState) => {
      var _a, _b, _c;
      const { state, composing } = view2;
      const { selection } = state;
      const isSame = !selectionChanged && !docChanged;
      if (composing || isSame) {
        return;
      }
      this.createTooltip();
      const { ranges } = selection;
      const from = Math.min(...ranges.map((range) => range.$from.pos));
      const to2 = Math.max(...ranges.map((range) => range.$to.pos));
      const shouldShow2 = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
        editor: this.editor,
        view: view2,
        state,
        oldState,
        from,
        to: to2
      });
      if (!shouldShow2) {
        this.hide();
        return;
      }
      (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
        getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {
          if (isNodeSelection(state.selection)) {
            let node = view2.nodeDOM(from);
            const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector("[data-node-view-wrapper]");
            if (nodeViewWrapper) {
              node = nodeViewWrapper.firstChild;
            }
            if (node) {
              return node.getBoundingClientRect();
            }
          }
          return posToDOMRect(view2, from, to2);
        })
      });
      this.show();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    this.updateDelay = updateDelay;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.addEventListener("dragstart", this.dragstartHandler);
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy_esm_default(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
    }
  }
  update(view, oldState) {
    const { state } = view;
    const hasValidSelection = state.selection.from !== state.selection.to;
    if (this.updateDelay > 0 && hasValidSelection) {
      this.handleDebouncedUpdate(view, oldState);
      return;
    }
    const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));
    const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));
    this.updateHandler(view, selectionChanged, docChanged, oldState);
  }
  show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a, _b;
    if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {
      this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
};
var BubbleMenuPlugin = (options) => {
  return new Plugin({
    key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
    view: (view) => new BubbleMenuView({ view, ...options })
  });
};
var BubbleMenu = Extension.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      BubbleMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});

// node_modules/@tiptap/react/dist/index.js
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@tiptap/extension-floating-menu/dist/index.js
var FloatingMenuView = class {
  constructor({ editor, element, view, tippyOptions = {}, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state }) => {
      const { selection } = state;
      const { $anchor, empty } = selection;
      const isRootDepth = $anchor.depth === 1;
      const isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent;
      if (!view2.hasFocus() || !empty || !isRootDepth || !isEmptyTextBlock || !this.editor.isEditable) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      this.hide();
    };
    this.tippyBlurHandler = (event) => {
      this.blurHandler({ event });
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy_esm_default(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
    }
  }
  update(view, oldState) {
    var _a, _b, _c;
    const { state } = view;
    const { doc, selection } = state;
    const { from, to: to2 } = selection;
    const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);
    if (isSame) {
      return;
    }
    this.createTooltip();
    const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
      editor: this.editor,
      view,
      state,
      oldState
    });
    if (!shouldShow) {
      this.hide();
      return;
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
      getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => posToDOMRect(view, from, to2))
    });
    this.show();
  }
  show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a, _b;
    if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {
      this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
};
var FloatingMenuPlugin = (options) => {
  return new Plugin({
    key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
    view: (view) => new FloatingMenuView({ view, ...options })
  });
};
var FloatingMenu = Extension.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      FloatingMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});

// node_modules/@tiptap/react/dist/index.js
var shim = { exports: {} };
var useSyncExternalStoreShim_development = {};
var hasRequiredUseSyncExternalStoreShim_development;
function requireUseSyncExternalStoreShim_development() {
  if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;
  hasRequiredUseSyncExternalStoreShim_development = 1;
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React$1 = import_react.default;
      var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function is(x2, y3) {
        return x2 === y3 && (x2 !== 0 || 1 / x2 === 1 / y3) || x2 !== x2 && y3 !== y3;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is;
      var useState2 = React$1.useState, useEffect2 = React$1.useEffect, useLayoutEffect = React$1.useLayoutEffect, useDebugValue2 = React$1.useDebugValue;
      var didWarnOld18Alpha = false;
      var didWarnUncachedGetSnapshot = false;
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        {
          if (!didWarnOld18Alpha) {
            if (React$1.startTransition !== void 0) {
              didWarnOld18Alpha = true;
              error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
            }
          }
        }
        var value = getSnapshot();
        {
          if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            if (!objectIs(value, cachedValue)) {
              error("The result of getSnapshot should be cached to avoid an infinite loop");
              didWarnUncachedGetSnapshot = true;
            }
          }
        }
        var _useState = useState2({
          inst: {
            value,
            getSnapshot
          }
        }), inst = _useState[0].inst, forceUpdate = _useState[1];
        useLayoutEffect(function() {
          inst.value = value;
          inst.getSnapshot = getSnapshot;
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({
              inst
            });
          }
        }, [subscribe, value, getSnapshot]);
        useEffect2(function() {
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({
              inst
            });
          }
          var handleStoreChange = function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          };
          return subscribe(handleStoreChange);
        }, [subscribe]);
        useDebugValue2(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        var prevValue = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(prevValue, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
        return getSnapshot();
      }
      var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
      var isServerEnvironment = !canUseDOM;
      var shim2 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
      var useSyncExternalStore$2 = React$1.useSyncExternalStore !== void 0 ? React$1.useSyncExternalStore : shim2;
      useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  return useSyncExternalStoreShim_development;
}
if (false) {
  shim.exports = requireUseSyncExternalStoreShim_production_min();
} else {
  shim.exports = requireUseSyncExternalStoreShim_development();
}
var shimExports = shim.exports;
var mergeRefs2 = (...refs) => {
  return (node) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(node);
      } else if (ref) {
        ref.current = node;
      }
    });
  };
};
var Portals = ({ contentComponent }) => {
  const renderers = shimExports.useSyncExternalStore(contentComponent.subscribe, contentComponent.getSnapshot, contentComponent.getServerSnapshot);
  return import_react.default.createElement(import_react.default.Fragment, null, Object.values(renderers));
};
function getInstance() {
  const subscribers = /* @__PURE__ */ new Set();
  let renderers = {};
  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(callback) {
      subscribers.add(callback);
      return () => {
        subscribers.delete(callback);
      };
    },
    getSnapshot() {
      return renderers;
    },
    getServerSnapshot() {
      return renderers;
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(id, renderer) {
      renderers = {
        ...renderers,
        [id]: import_react_dom.default.createPortal(renderer.reactElement, renderer.element, id)
      };
      subscribers.forEach((subscriber) => subscriber());
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(id) {
      const nextRenderers = { ...renderers };
      delete nextRenderers[id];
      renderers = nextRenderers;
      subscribers.forEach((subscriber) => subscriber());
    }
  };
}
var PureEditorContent = class extends import_react.default.Component {
  constructor(props) {
    var _a;
    super(props);
    this.editorContentRef = import_react.default.createRef();
    this.initialized = false;
    this.state = {
      hasContentComponentInitialized: Boolean((_a = props.editor) === null || _a === void 0 ? void 0 : _a.contentComponent)
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    const editor = this.props.editor;
    if (editor && !editor.isDestroyed && editor.options.element) {
      if (editor.contentComponent) {
        return;
      }
      const element = this.editorContentRef.current;
      element.append(...editor.options.element.childNodes);
      editor.setOptions({
        element
      });
      editor.contentComponent = getInstance();
      if (!this.state.hasContentComponentInitialized) {
        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {
          this.setState((prevState) => {
            if (!prevState.hasContentComponentInitialized) {
              return {
                hasContentComponentInitialized: true
              };
            }
            return prevState;
          });
          if (this.unsubscribeToContentComponent) {
            this.unsubscribeToContentComponent();
          }
        });
      }
      editor.createNodeViews();
      this.initialized = true;
    }
  }
  componentWillUnmount() {
    const editor = this.props.editor;
    if (!editor) {
      return;
    }
    this.initialized = false;
    if (!editor.isDestroyed) {
      editor.view.setProps({
        nodeViews: {}
      });
    }
    if (this.unsubscribeToContentComponent) {
      this.unsubscribeToContentComponent();
    }
    editor.contentComponent = null;
    if (!editor.options.element.firstChild) {
      return;
    }
    const newElement = document.createElement("div");
    newElement.append(...editor.options.element.childNodes);
    editor.setOptions({
      element: newElement
    });
  }
  render() {
    const { editor, innerRef, ...rest } = this.props;
    return import_react.default.createElement(
      import_react.default.Fragment,
      null,
      import_react.default.createElement("div", { ref: mergeRefs2(innerRef, this.editorContentRef), ...rest }),
      (editor === null || editor === void 0 ? void 0 : editor.contentComponent) && import_react.default.createElement(Portals, { contentComponent: editor.contentComponent })
    );
  }
};
var EditorContentWithKey = (0, import_react.forwardRef)((props, ref) => {
  const key = import_react.default.useMemo(() => {
    return Math.floor(Math.random() * 4294967295).toString();
  }, [props.editor]);
  return import_react.default.createElement(PureEditorContent, {
    key,
    innerRef: ref,
    ...props
  });
});
var EditorContent = import_react.default.memo(EditorContentWithKey);
var withSelector = { exports: {} };
var withSelector_development = {};
var hasRequiredWithSelector_development;
function requireWithSelector_development() {
  if (hasRequiredWithSelector_development) return withSelector_development;
  hasRequiredWithSelector_development = 1;
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React$1 = import_react.default;
      var shim2 = shimExports;
      function is(x2, y3) {
        return x2 === y3 && (x2 !== 0 || 1 / x2 === 1 / y3) || x2 !== x2 && y3 !== y3;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is;
      var useSyncExternalStore = shim2.useSyncExternalStore;
      var useRef2 = React$1.useRef, useEffect2 = React$1.useEffect, useMemo = React$1.useMemo, useDebugValue2 = React$1.useDebugValue;
      function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef2(null);
        var inst;
        if (instRef.current === null) {
          inst = {
            hasValue: false,
            value: null
          };
          instRef.current = inst;
        } else {
          inst = instRef.current;
        }
        var _useMemo = useMemo(function() {
          var hasMemo = false;
          var memoizedSnapshot;
          var memoizedSelection;
          var memoizedSelector = function(nextSnapshot) {
            if (!hasMemo) {
              hasMemo = true;
              memoizedSnapshot = nextSnapshot;
              var _nextSelection = selector(nextSnapshot);
              if (isEqual !== void 0) {
                if (inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, _nextSelection)) {
                    memoizedSelection = currentSelection;
                    return currentSelection;
                  }
                }
              }
              memoizedSelection = _nextSelection;
              return _nextSelection;
            }
            var prevSnapshot = memoizedSnapshot;
            var prevSelection = memoizedSelection;
            if (objectIs(prevSnapshot, nextSnapshot)) {
              return prevSelection;
            }
            var nextSelection = selector(nextSnapshot);
            if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
              return prevSelection;
            }
            memoizedSnapshot = nextSnapshot;
            memoizedSelection = nextSelection;
            return nextSelection;
          };
          var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
          var getSnapshotWithSelector = function() {
            return memoizedSelector(getSnapshot());
          };
          var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          };
          return [getSnapshotWithSelector, getServerSnapshotWithSelector];
        }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
        var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
        useEffect2(function() {
          inst.hasValue = true;
          inst.value = value;
        }, [value]);
        useDebugValue2(value);
        return value;
      }
      withSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  return withSelector_development;
}
if (false) {
  withSelector.exports = requireWithSelector_production_min();
} else {
  withSelector.exports = requireWithSelector_development();
}
var withSelectorExports = withSelector.exports;
var isSSR = typeof window === "undefined";
var isNext = isSSR || Boolean(typeof window !== "undefined" && window.next);
var EditorContext = (0, import_react.createContext)({
  editor: null
});
var EditorConsumer = EditorContext.Consumer;
var ReactNodeViewContext = (0, import_react.createContext)({
  onDragStart: void 0
});
var useReactNodeView = () => (0, import_react.useContext)(ReactNodeViewContext);
var NodeViewContent = (props) => {
  const Tag = props.as || "div";
  const { nodeViewContentRef } = useReactNodeView();
  return (
    // @ts-ignore
    import_react.default.createElement(Tag, { ...props, ref: nodeViewContentRef, "data-node-view-content": "", style: {
      whiteSpace: "pre-wrap",
      ...props.style
    } })
  );
};
var NodeViewWrapper = import_react.default.forwardRef((props, ref) => {
  const { onDragStart } = useReactNodeView();
  const Tag = props.as || "div";
  return (
    // @ts-ignore
    import_react.default.createElement(Tag, { ...props, ref, "data-node-view-wrapper": "", onDragStart, style: {
      whiteSpace: "normal",
      ...props.style
    } })
  );
});
function isClassComponent(Component) {
  return !!(typeof Component === "function" && Component.prototype && Component.prototype.isReactComponent);
}
function isForwardRefComponent(Component) {
  var _a;
  return !!(typeof Component === "object" && ((_a = Component.$$typeof) === null || _a === void 0 ? void 0 : _a.toString()) === "Symbol(react.forward_ref)");
}
var ReactRenderer = class {
  constructor(component, { editor, props = {}, as = "div", className = "", attrs }) {
    this.ref = null;
    this.id = Math.floor(Math.random() * 4294967295).toString();
    this.component = component;
    this.editor = editor;
    this.props = props;
    this.element = document.createElement(as);
    this.element.classList.add("react-renderer");
    if (className) {
      this.element.classList.add(...className.split(" "));
    }
    if (attrs) {
      Object.keys(attrs).forEach((key) => {
        this.element.setAttribute(key, attrs[key]);
      });
    }
    if (this.editor.isInitialized) {
      (0, import_react_dom.flushSync)(() => {
        this.render();
      });
    } else {
      this.render();
    }
  }
  render() {
    var _a;
    const Component = this.component;
    const props = this.props;
    const editor = this.editor;
    if (isClassComponent(Component) || isForwardRefComponent(Component)) {
      props.ref = (ref) => {
        this.ref = ref;
      };
    }
    this.reactElement = import_react.default.createElement(Component, props);
    (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.setRenderer(this.id, this);
  }
  updateProps(props = {}) {
    this.props = {
      ...this.props,
      ...props
    };
    this.render();
  }
  destroy() {
    var _a;
    const editor = this.editor;
    (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.removeRenderer(this.id);
  }
};
var ReactNodeView = class extends NodeView {
  mount() {
    const props = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      selected: false,
      extension: this.extension,
      getPos: () => this.getPos(),
      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),
      deleteNode: () => this.deleteNode()
    };
    if (!this.component.displayName) {
      const capitalizeFirstChar = (string) => {
        return string.charAt(0).toUpperCase() + string.substring(1);
      };
      this.component.displayName = capitalizeFirstChar(this.extension.name);
    }
    const onDragStart = this.onDragStart.bind(this);
    const nodeViewContentRef = (element) => {
      if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {
        element.appendChild(this.contentDOMElement);
      }
    };
    const context = { onDragStart, nodeViewContentRef };
    const Component = this.component;
    const ReactNodeViewProvider = import_react.default.memo((componentProps) => {
      return import_react.default.createElement(ReactNodeViewContext.Provider, { value: context }, import_react.default.createElement(Component, componentProps));
    });
    ReactNodeViewProvider.displayName = "ReactNodeView";
    if (this.node.isLeaf) {
      this.contentDOMElement = null;
    } else if (this.options.contentDOMElementTag) {
      this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);
    } else {
      this.contentDOMElement = document.createElement(this.node.isInline ? "span" : "div");
    }
    if (this.contentDOMElement) {
      this.contentDOMElement.style.whiteSpace = "inherit";
    }
    let as = this.node.isInline ? "span" : "div";
    if (this.options.as) {
      as = this.options.as;
    }
    const { className = "" } = this.options;
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);
    this.editor.on("selectionUpdate", this.handleSelectionUpdate);
    this.renderer = new ReactRenderer(ReactNodeViewProvider, {
      editor: this.editor,
      props,
      as,
      className: `node-${this.node.type.name} ${className}`.trim(),
      attrs: this.options.attrs
    });
  }
  get dom() {
    var _a;
    if (this.renderer.element.firstElementChild && !((_a = this.renderer.element.firstElementChild) === null || _a === void 0 ? void 0 : _a.hasAttribute("data-node-view-wrapper"))) {
      throw Error("Please use the NodeViewWrapper component for your node view.");
    }
    return this.renderer.element;
  }
  get contentDOM() {
    if (this.node.isLeaf) {
      return null;
    }
    return this.contentDOMElement;
  }
  handleSelectionUpdate() {
    const { from, to: to2 } = this.editor.state.selection;
    if (from <= this.getPos() && to2 >= this.getPos() + this.node.nodeSize) {
      if (this.renderer.props.selected) {
        return;
      }
      this.selectNode();
    } else {
      if (!this.renderer.props.selected) {
        return;
      }
      this.deselectNode();
    }
  }
  update(node, decorations) {
    const updateProps = (props) => {
      this.renderer.updateProps(props);
    };
    if (node.type !== this.node.type) {
      return false;
    }
    if (typeof this.options.update === "function") {
      const oldNode = this.node;
      const oldDecorations = this.decorations;
      this.node = node;
      this.decorations = decorations;
      return this.options.update({
        oldNode,
        oldDecorations,
        newNode: node,
        newDecorations: decorations,
        updateProps: () => updateProps({ node, decorations })
      });
    }
    if (node === this.node && this.decorations === decorations) {
      return true;
    }
    this.node = node;
    this.decorations = decorations;
    updateProps({ node, decorations });
    return true;
  }
  selectNode() {
    this.renderer.updateProps({
      selected: true
    });
    this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  deselectNode() {
    this.renderer.updateProps({
      selected: false
    });
    this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  destroy() {
    this.renderer.destroy();
    this.editor.off("selectionUpdate", this.handleSelectionUpdate);
    this.contentDOMElement = null;
  }
};
function ReactNodeViewRenderer(component, options) {
  return (props) => {
    if (!props.editor.contentComponent) {
      return {};
    }
    return new ReactNodeView(component, props, options);
  };
}

// node_modules/@blocknote/react/dist/blocknote-react.js
var Xt = (0, import_react2.createContext)(void 0);
function z2(e) {
  return (0, import_react2.useContext)(Xt);
}
var We = { exports: {} };
var ie = {};
var St;
function Ho() {
  return St || (St = 1, function() {
    var e = import_react2.default, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), l2 = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), c = Symbol.for("react.provider"), u = Symbol.for("react.context"), d = Symbol.for("react.forward_ref"), s = Symbol.for("react.suspense"), m = Symbol.for("react.suspense_list"), g = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), v = Symbol.for("react.offscreen"), E = Symbol.iterator, B = "@@iterator";
    function T(i) {
      if (i === null || typeof i != "object")
        return null;
      var f = E && i[E] || i[B];
      return typeof f == "function" ? f : null;
    }
    var M = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function O2(i) {
      {
        for (var f = arguments.length, b = new Array(f > 1 ? f - 1 : 0), p = 1; p < f; p++)
          b[p - 1] = arguments[p];
        G("error", i, b);
      }
    }
    function G(i, f, b) {
      {
        var p = M.ReactDebugCurrentFrame, _ = p.getStackAddendum();
        _ !== "" && (f += "%s", b = b.concat([_]));
        var L = b.map(function(j) {
          return String(j);
        });
        L.unshift("Warning: " + f), Function.prototype.apply.call(console[i], console, L);
      }
    }
    var _e = false, Ve2 = false, ue = false, Ee = false, Te = false, de;
    de = Symbol.for("react.module.reference");
    function Le(i) {
      return !!(typeof i == "string" || typeof i == "function" || i === o || i === a || Te || i === l2 || i === s || i === m || Ee || i === v || _e || Ve2 || ue || typeof i == "object" && i !== null && (i.$$typeof === h || i.$$typeof === g || i.$$typeof === c || i.$$typeof === u || i.$$typeof === d || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      i.$$typeof === de || i.getModuleId !== void 0));
    }
    function pn(i, f, b) {
      var p = i.displayName;
      if (p)
        return p;
      var _ = f.displayName || f.name || "";
      return _ !== "" ? b + "(" + _ + ")" : b;
    }
    function et(i) {
      return i.displayName || "Context";
    }
    function Z2(i) {
      if (i == null)
        return null;
      if (typeof i.tag == "number" && O2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof i == "function")
        return i.displayName || i.name || null;
      if (typeof i == "string")
        return i;
      switch (i) {
        case o:
          return "Fragment";
        case n:
          return "Portal";
        case a:
          return "Profiler";
        case l2:
          return "StrictMode";
        case s:
          return "Suspense";
        case m:
          return "SuspenseList";
      }
      if (typeof i == "object")
        switch (i.$$typeof) {
          case u:
            var f = i;
            return et(f) + ".Consumer";
          case c:
            var b = i;
            return et(b._context) + ".Provider";
          case d:
            return pn(i, i.render, "ForwardRef");
          case g:
            var p = i.displayName || null;
            return p !== null ? p : Z2(i.type) || "Memo";
          case h: {
            var _ = i, L = _._payload, j = _._init;
            try {
              return Z2(j(L));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var $ = Object.assign, te = 0, tt, nt, ot, rt2, it2, lt2, at2;
    function ct3() {
    }
    ct3.__reactDisabledLog = true;
    function xn() {
      {
        if (te === 0) {
          tt = console.log, nt = console.info, ot = console.warn, rt2 = console.error, it2 = console.group, lt2 = console.groupCollapsed, at2 = console.groupEnd;
          var i = {
            configurable: true,
            enumerable: true,
            value: ct3,
            writable: true
          };
          Object.defineProperties(console, {
            info: i,
            log: i,
            warn: i,
            error: i,
            group: i,
            groupCollapsed: i,
            groupEnd: i
          });
        }
        te++;
      }
    }
    function vn() {
      {
        if (te--, te === 0) {
          var i = {
            configurable: true,
            enumerable: true,
            writable: true
          };
          Object.defineProperties(console, {
            log: $({}, i, {
              value: tt
            }),
            info: $({}, i, {
              value: nt
            }),
            warn: $({}, i, {
              value: ot
            }),
            error: $({}, i, {
              value: rt2
            }),
            group: $({}, i, {
              value: it2
            }),
            groupCollapsed: $({}, i, {
              value: lt2
            }),
            groupEnd: $({}, i, {
              value: at2
            })
          });
        }
        te < 0 && O2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Re = M.ReactCurrentDispatcher, Be2;
    function fe2(i, f, b) {
      {
        if (Be2 === void 0)
          try {
            throw Error();
          } catch (_) {
            var p = _.stack.trim().match(/\n( *(at )?)/);
            Be2 = p && p[1] || "";
          }
        return `
` + Be2 + i;
      }
    }
    var Pe = false, ge;
    {
      var Cn = typeof WeakMap == "function" ? WeakMap : Map;
      ge = new Cn();
    }
    function st2(i, f) {
      if (!i || Pe)
        return "";
      {
        var b = ge.get(i);
        if (b !== void 0)
          return b;
      }
      var p;
      Pe = true;
      var _ = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var L;
      L = Re.current, Re.current = null, xn();
      try {
        if (f) {
          var j = function() {
            throw Error();
          };
          if (Object.defineProperty(j.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(j, []);
            } catch (I) {
              p = I;
            }
            Reflect.construct(i, [], j);
          } else {
            try {
              j.call();
            } catch (I) {
              p = I;
            }
            i.call(j.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (I) {
            p = I;
          }
          i();
        }
      } catch (I) {
        if (I && p && typeof I.stack == "string") {
          for (var k = I.stack.split(`
`), N = p.stack.split(`
`), P = k.length - 1, F = N.length - 1; P >= 1 && F >= 0 && k[P] !== N[F]; )
            F--;
          for (; P >= 1 && F >= 0; P--, F--)
            if (k[P] !== N[F]) {
              if (P !== 1 || F !== 1)
                do
                  if (P--, F--, F < 0 || k[P] !== N[F]) {
                    var A = `
` + k[P].replace(" at new ", " at ");
                    return i.displayName && A.includes("<anonymous>") && (A = A.replace("<anonymous>", i.displayName)), typeof i == "function" && ge.set(i, A), A;
                  }
                while (P >= 1 && F >= 0);
              break;
            }
        }
      } finally {
        Pe = false, Re.current = L, vn(), Error.prepareStackTrace = _;
      }
      var J = i ? i.displayName || i.name : "", q = J ? fe2(J) : "";
      return typeof i == "function" && ge.set(i, q), q;
    }
    function kn(i, f, b) {
      return st2(i, false);
    }
    function yn(i) {
      var f = i.prototype;
      return !!(f && f.isReactComponent);
    }
    function me(i, f, b) {
      if (i == null)
        return "";
      if (typeof i == "function")
        return st2(i, yn(i));
      if (typeof i == "string")
        return fe2(i);
      switch (i) {
        case s:
          return fe2("Suspense");
        case m:
          return fe2("SuspenseList");
      }
      if (typeof i == "object")
        switch (i.$$typeof) {
          case d:
            return kn(i.render);
          case g:
            return me(i.type, f, b);
          case h: {
            var p = i, _ = p._payload, L = p._init;
            try {
              return me(L(_), f, b);
            } catch {
            }
          }
        }
      return "";
    }
    var ne = Object.prototype.hasOwnProperty, ut2 = {}, dt2 = M.ReactDebugCurrentFrame;
    function he(i) {
      if (i) {
        var f = i._owner, b = me(i.type, i._source, f ? f.type : null);
        dt2.setExtraStackFrame(b);
      } else
        dt2.setExtraStackFrame(null);
    }
    function jn(i, f, b, p, _) {
      {
        var L = Function.call.bind(ne);
        for (var j in i)
          if (L(i, j)) {
            var k = void 0;
            try {
              if (typeof i[j] != "function") {
                var N = Error((p || "React class") + ": " + b + " type `" + j + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[j] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw N.name = "Invariant Violation", N;
              }
              k = i[j](f, j, p, b, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (P) {
              k = P;
            }
            k && !(k instanceof Error) && (he(_), O2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", p || "React class", b, j, typeof k), he(null)), k instanceof Error && !(k.message in ut2) && (ut2[k.message] = true, he(_), O2("Failed %s type: %s", b, k.message), he(null));
          }
      }
    }
    var wn = Array.isArray;
    function Oe(i) {
      return wn(i);
    }
    function Hn(i) {
      {
        var f = typeof Symbol == "function" && Symbol.toStringTag, b = f && i[Symbol.toStringTag] || i.constructor.name || "Object";
        return b;
      }
    }
    function Sn(i) {
      try {
        return ft2(i), false;
      } catch {
        return true;
      }
    }
    function ft2(i) {
      return "" + i;
    }
    function gt2(i) {
      if (Sn(i))
        return O2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Hn(i)), ft2(i);
    }
    var oe = M.ReactCurrentOwner, Mn = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    }, mt2, ht2, Fe;
    Fe = {};
    function _n(i) {
      if (ne.call(i, "ref")) {
        var f = Object.getOwnPropertyDescriptor(i, "ref").get;
        if (f && f.isReactWarning)
          return false;
      }
      return i.ref !== void 0;
    }
    function Vn(i) {
      if (ne.call(i, "key")) {
        var f = Object.getOwnPropertyDescriptor(i, "key").get;
        if (f && f.isReactWarning)
          return false;
      }
      return i.key !== void 0;
    }
    function En(i, f) {
      if (typeof i.ref == "string" && oe.current && f && oe.current.stateNode !== f) {
        var b = Z2(oe.current.type);
        Fe[b] || (O2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Z2(oe.current.type), i.ref), Fe[b] = true);
      }
    }
    function Tn(i, f) {
      {
        var b = function() {
          mt2 || (mt2 = true, O2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", f));
        };
        b.isReactWarning = true, Object.defineProperty(i, "key", {
          get: b,
          configurable: true
        });
      }
    }
    function Ln(i, f) {
      {
        var b = function() {
          ht2 || (ht2 = true, O2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", f));
        };
        b.isReactWarning = true, Object.defineProperty(i, "ref", {
          get: b,
          configurable: true
        });
      }
    }
    var Rn = function(i, f, b, p, _, L, j) {
      var k = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: i,
        key: f,
        ref: b,
        props: j,
        // Record the component responsible for creating this element.
        _owner: L
      };
      return k._store = {}, Object.defineProperty(k._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      }), Object.defineProperty(k, "_self", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: p
      }), Object.defineProperty(k, "_source", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: _
      }), Object.freeze && (Object.freeze(k.props), Object.freeze(k)), k;
    };
    function Bn(i, f, b, p, _) {
      {
        var L, j = {}, k = null, N = null;
        b !== void 0 && (gt2(b), k = "" + b), Vn(f) && (gt2(f.key), k = "" + f.key), _n(f) && (N = f.ref, En(f, _));
        for (L in f)
          ne.call(f, L) && !Mn.hasOwnProperty(L) && (j[L] = f[L]);
        if (i && i.defaultProps) {
          var P = i.defaultProps;
          for (L in P)
            j[L] === void 0 && (j[L] = P[L]);
        }
        if (k || N) {
          var F = typeof i == "function" ? i.displayName || i.name || "Unknown" : i;
          k && Tn(j, F), N && Ln(j, F);
        }
        return Rn(i, k, N, _, p, oe.current, j);
      }
    }
    var Ne = M.ReactCurrentOwner, bt2 = M.ReactDebugCurrentFrame;
    function X(i) {
      if (i) {
        var f = i._owner, b = me(i.type, i._source, f ? f.type : null);
        bt2.setExtraStackFrame(b);
      } else
        bt2.setExtraStackFrame(null);
    }
    var Ie;
    Ie = false;
    function De(i) {
      return typeof i == "object" && i !== null && i.$$typeof === t;
    }
    function pt2() {
      {
        if (Ne.current) {
          var i = Z2(Ne.current.type);
          if (i)
            return `

Check the render method of \`` + i + "`.";
        }
        return "";
      }
    }
    function Pn(i) {
      return "";
    }
    var xt2 = {};
    function On(i) {
      {
        var f = pt2();
        if (!f) {
          var b = typeof i == "string" ? i : i.displayName || i.name;
          b && (f = `

Check the top-level render call using <` + b + ">.");
        }
        return f;
      }
    }
    function vt3(i, f) {
      {
        if (!i._store || i._store.validated || i.key != null)
          return;
        i._store.validated = true;
        var b = On(f);
        if (xt2[b])
          return;
        xt2[b] = true;
        var p = "";
        i && i._owner && i._owner !== Ne.current && (p = " It was passed a child from " + Z2(i._owner.type) + "."), X(i), O2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', b, p), X(null);
      }
    }
    function Ct2(i, f) {
      {
        if (typeof i != "object")
          return;
        if (Oe(i))
          for (var b = 0; b < i.length; b++) {
            var p = i[b];
            De(p) && vt3(p, f);
          }
        else if (De(i))
          i._store && (i._store.validated = true);
        else if (i) {
          var _ = T(i);
          if (typeof _ == "function" && _ !== i.entries)
            for (var L = _.call(i), j; !(j = L.next()).done; )
              De(j.value) && vt3(j.value, f);
        }
      }
    }
    function Fn(i) {
      {
        var f = i.type;
        if (f == null || typeof f == "string")
          return;
        var b;
        if (typeof f == "function")
          b = f.propTypes;
        else if (typeof f == "object" && (f.$$typeof === d || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        f.$$typeof === g))
          b = f.propTypes;
        else
          return;
        if (b) {
          var p = Z2(f);
          jn(b, i.props, "prop", p, i);
        } else if (f.PropTypes !== void 0 && !Ie) {
          Ie = true;
          var _ = Z2(f);
          O2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _ || "Unknown");
        }
        typeof f.getDefaultProps == "function" && !f.getDefaultProps.isReactClassApproved && O2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Nn(i) {
      {
        for (var f = Object.keys(i.props), b = 0; b < f.length; b++) {
          var p = f[b];
          if (p !== "children" && p !== "key") {
            X(i), O2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", p), X(null);
            break;
          }
        }
        i.ref !== null && (X(i), O2("Invalid attribute `ref` supplied to `React.Fragment`."), X(null));
      }
    }
    var kt2 = {};
    function yt2(i, f, b, p, _, L) {
      {
        var j = Le(i);
        if (!j) {
          var k = "";
          (i === void 0 || typeof i == "object" && i !== null && Object.keys(i).length === 0) && (k += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var N = Pn();
          N ? k += N : k += pt2();
          var P;
          i === null ? P = "null" : Oe(i) ? P = "array" : i !== void 0 && i.$$typeof === t ? (P = "<" + (Z2(i.type) || "Unknown") + " />", k = " Did you accidentally export a JSX literal instead of a component?") : P = typeof i, O2("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", P, k);
        }
        var F = Bn(i, f, b, _, L);
        if (F == null)
          return F;
        if (j) {
          var A = f.children;
          if (A !== void 0)
            if (p)
              if (Oe(A)) {
                for (var J = 0; J < A.length; J++)
                  Ct2(A[J], i);
                Object.freeze && Object.freeze(A);
              } else
                O2("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ct2(A, i);
        }
        if (ne.call(f, "key")) {
          var q = Z2(i), I = Object.keys(f).filter(function(zn) {
            return zn !== "key";
          }), Ae = I.length > 0 ? "{key: someKey, " + I.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!kt2[q + Ae]) {
            var Un = I.length > 0 ? "{" + I.join(": ..., ") + ": ...}" : "{}";
            O2(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Ae, q, Un, q), kt2[q + Ae] = true;
          }
        }
        return i === o ? Nn(F) : Fn(F), F;
      }
    }
    function In(i, f, b) {
      return yt2(i, f, b, true);
    }
    function Dn(i, f, b) {
      return yt2(i, f, b, false);
    }
    var An = Dn, Zn = In;
    ie.Fragment = o, ie.jsx = An, ie.jsxs = Zn;
  }()), ie;
}
false ? We.exports = wo() : We.exports = Ho();
var r = We.exports;
function H(e) {
  const t = z2();
  if (!(t != null && t.editor))
    throw new Error(
      "useBlockNoteEditor was called outside of a BlockNoteContext provider or BlockNoteView component"
    );
  return t.editor;
}
function Ye(e, t) {
  const n = z2();
  t || (t = n == null ? void 0 : n.editor), (0, import_react2.useEffect)(() => {
    if (!t)
      throw new Error(
        "'editor' is required, either from BlockNoteContext or as a function argument"
      );
    return t.onChange(e);
  }, [e, t]);
}
function Ke(e, t) {
  const n = z2();
  t || (t = n == null ? void 0 : n.editor), (0, import_react2.useEffect)(() => {
    if (!t)
      throw new Error(
        "'editor' is required, either from BlockNoteContext or as a function argument"
      );
    return t.onSelectionChange(e);
  }, [e, t]);
}
function W(e, t) {
  Ye(e, t), Ke(e, t);
}
function ee(e, t, n, o) {
  const { refs: l2, update: a, context: c, floatingStyles: u } = useFloating({
    open: e,
    ...o
  }), { isMounted: d, styles: s } = useTransitionStyles(c), m = useDismiss(c), { getReferenceProps: g, getFloatingProps: h } = useInteractions([m]);
  return (0, import_react2.useEffect)(() => {
    a();
  }, [t, a]), (0, import_react2.useEffect)(() => {
    t !== null && l2.setReference({
      getBoundingClientRect: () => t
    });
  }, [t, l2]), (0, import_react2.useMemo)(
    () => ({
      isMounted: d,
      ref: l2.setFloating,
      style: {
        display: "flex",
        ...s,
        ...u,
        zIndex: n
      },
      getFloatingProps: h,
      getReferenceProps: g
    }),
    [
      u,
      d,
      l2.setFloating,
      s,
      n,
      h,
      g
    ]
  );
}
function K(e) {
  const [t, n] = (0, import_react2.useState)();
  return (0, import_react2.useEffect)(() => e((o) => {
    n({ ...o });
  }), [e]), t;
}
function So(e) {
  return (t) => {
    e.forEach((n) => {
      typeof n == "function" ? n(t) : n != null && (n.current = t);
    });
  };
}
var Mo = (0, import_react2.createContext)(
  void 0
);
function C() {
  return (0, import_react2.useContext)(Mo);
}
var Jt = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var Mt = import_react2.default.createContext && import_react2.default.createContext(Jt);
var _o = ["attr", "size", "title"];
function Vo2(e, t) {
  if (e == null) return {};
  var n = Eo(e, t), o, l2;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (l2 = 0; l2 < a.length; l2++)
      o = a[l2], !(t.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(e, o) && (n[o] = e[o]);
  }
  return n;
}
function Eo(e, t) {
  if (e == null) return {};
  var n = {};
  for (var o in e)
    if (Object.prototype.hasOwnProperty.call(e, o)) {
      if (t.indexOf(o) >= 0) continue;
      n[o] = e[o];
    }
  return n;
}
function ve() {
  return ve = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, ve.apply(this, arguments);
}
function _t(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(l2) {
      return Object.getOwnPropertyDescriptor(e, l2).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function Ce(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _t(Object(n), true).forEach(function(o) {
      To(e, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _t(Object(n)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return e;
}
function To(e, t, n) {
  return t = Lo(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: true, configurable: true, writable: true }) : e[t] = n, e;
}
function Lo(e) {
  var t = Ro(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function Ro(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(e, t || "default");
    if (typeof o != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Qt(e) {
  return e && e.map((t, n) => import_react2.default.createElement(t.tag, Ce({
    key: n
  }, t.attr), Qt(t.child)));
}
function y(e) {
  return (t) => import_react2.default.createElement(Bo, ve({
    attr: Ce({}, e.attr)
  }, t), Qt(e.child));
}
function Bo(e) {
  var t = (n) => {
    var {
      attr: o,
      size: l2,
      title: a
    } = e, c = Vo2(e, _o), u = l2 || n.size || "1em", d;
    return n.className && (d = n.className), e.className && (d = (d ? d + " " : "") + e.className), import_react2.default.createElement("svg", ve({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, n.attr, o, c, {
      className: d,
      style: Ce(Ce({
        color: e.color || n.color
      }, n.style), e.style),
      height: u,
      width: u,
      xmlns: "http://www.w3.org/2000/svg"
    }), a && import_react2.default.createElement("title", null, a), e.children);
  };
  return Mt !== void 0 ? import_react2.default.createElement(Mt.Consumer, null, (n) => t(n)) : t(Jt);
}
function Po(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M23 12L15.9289 19.0711L14.5147 17.6569L20.1716 12L14.5147 6.34317L15.9289 4.92896L23 12ZM3.82843 12L9.48528 17.6569L8.07107 19.0711L1 12L8.07107 4.92896L9.48528 6.34317L3.82843 12Z" }, child: [] }] })(e);
}
function je(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z" }, child: [] }] })(e);
}
function Oo(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM5 19H19V21H5V19ZM3 14H21V16H3V14ZM5 9H19V11H5V9Z" }, child: [] }] })(e);
}
function Fo(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM3 19H21V21H3V19ZM3 14H21V16H3V14ZM3 9H21V11H3V9Z" }, child: [] }] })(e);
}
function No(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM3 19H17V21H3V19ZM3 14H21V16H3V14ZM3 9H17V11H3V9Z" }, child: [] }] })(e);
}
function Io(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM7 19H21V21H7V19ZM3 14H21V16H3V14ZM7 9H21V11H7V9Z" }, child: [] }] })(e);
}
function Do(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 11H12.5C13.8807 11 15 9.88071 15 8.5C15 7.11929 13.8807 6 12.5 6H8V11ZM18 15.5C18 17.9853 15.9853 20 13.5 20H6V4H12.5C14.9853 4 17 6.01472 17 8.5C17 9.70431 16.5269 10.7981 15.7564 11.6058C17.0979 12.3847 18 13.837 18 15.5ZM8 13V18H13.5C14.8807 18 16 16.8807 16 15.5C16 14.1193 14.8807 13 13.5 13H8Z" }, child: [] }] })(e);
}
function Vt(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M5.55397 22H3.3999L10.9999 3H12.9999L20.5999 22H18.4458L16.0458 16H7.95397L5.55397 22ZM8.75397 14H15.2458L11.9999 5.88517L8.75397 14Z" }, child: [] }] })(e);
}
function en(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M13 20H11V13H4V20H2V4H4V11H11V4H13V20ZM21.0005 8V20H19.0005L19 10.204L17 10.74V8.67L19.5005 8H21.0005Z" }, child: [] }] })(e);
}
function tn(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M4 4V11H11V4H13V20H11V13H4V20H2V4H4ZM18.5 8C20.5711 8 22.25 9.67893 22.25 11.75C22.25 12.6074 21.9623 13.3976 21.4781 14.0292L21.3302 14.2102L18.0343 18H22V20H15L14.9993 18.444L19.8207 12.8981C20.0881 12.5908 20.25 12.1893 20.25 11.75C20.25 10.7835 19.4665 10 18.5 10C17.5818 10 16.8288 10.7071 16.7558 11.6065L16.75 11.75H14.75C14.75 9.67893 16.4289 8 18.5 8Z" }, child: [] }] })(e);
}
function nn(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M22 8L21.9984 10L19.4934 12.883C21.0823 13.3184 22.25 14.7728 22.25 16.5C22.25 18.5711 20.5711 20.25 18.5 20.25C16.674 20.25 15.1528 18.9449 14.8184 17.2166L16.7821 16.8352C16.9384 17.6413 17.6481 18.25 18.5 18.25C19.4665 18.25 20.25 17.4665 20.25 16.5C20.25 15.5335 19.4665 14.75 18.5 14.75C18.214 14.75 17.944 14.8186 17.7056 14.9403L16.3992 13.3932L19.3484 10H15V8H22ZM4 4V11H11V4H13V20H11V13H4V20H2V4H4Z" }, child: [] }] })(e);
}
function Ao(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM3 19H21V21H3V19ZM11 14H21V16H11V14ZM11 9H21V11H11V9ZM3 12.5L7 9V16L3 12.5Z" }, child: [] }] })(e);
}
function Zo(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM3 19H21V21H3V19ZM11 14H21V16H11V14ZM11 9H21V11H11V9ZM7 12.5L3 16V9L7 12.5Z" }, child: [] }] })(e);
}
function Et(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 5H11V19H8V21H16V19H13V5H16V3H8V5ZM2 7C1.44772 7 1 7.44772 1 8V16C1 16.5523 1.44772 17 2 17H8V15H3V9H8V7H2ZM16 9H21V15H16V17H22C22.5523 17 23 16.5523 23 16V8C23 7.44772 22.5523 7 22 7H16V9Z" }, child: [] }] })(e);
}
function Uo(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M15 20H7V18H9.92661L12.0425 6H9V4H17V6H14.0734L11.9575 18H15V20Z" }, child: [] }] })(e);
}
function zo(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M17 17H22V19H19V22H17V17ZM7 7H2V5H5V2H7V7ZM18.364 15.5355L16.9497 14.1213L18.364 12.7071C20.3166 10.7545 20.3166 7.58866 18.364 5.63604C16.4113 3.68342 13.2455 3.68342 11.2929 5.63604L9.87868 7.05025L8.46447 5.63604L9.87868 4.22183C12.6123 1.48816 17.0445 1.48816 19.7782 4.22183C22.5118 6.9555 22.5118 11.3877 19.7782 14.1213L18.364 15.5355ZM15.5355 18.364L14.1213 19.7782C11.3877 22.5118 6.9555 22.5118 4.22183 19.7782C1.48816 17.0445 1.48816 12.6123 4.22183 9.87868L5.63604 8.46447L7.05025 9.87868L5.63604 11.2929C3.68342 13.2455 3.68342 16.4113 5.63604 18.364C7.58866 20.3166 10.7545 20.3166 12.7071 18.364L14.1213 16.9497L15.5355 18.364ZM14.8284 7.75736L16.2426 9.17157L9.17157 16.2426L7.75736 14.8284L14.8284 7.75736Z" }, child: [] }] })(e);
}
function on(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M18.3638 15.5355L16.9496 14.1213L18.3638 12.7071C20.3164 10.7545 20.3164 7.58866 18.3638 5.63604C16.4112 3.68341 13.2453 3.68341 11.2927 5.63604L9.87849 7.05025L8.46428 5.63604L9.87849 4.22182C12.6122 1.48815 17.0443 1.48815 19.778 4.22182C22.5117 6.95549 22.5117 11.3876 19.778 14.1213L18.3638 15.5355ZM15.5353 18.364L14.1211 19.7782C11.3875 22.5118 6.95531 22.5118 4.22164 19.7782C1.48797 17.0445 1.48797 12.6123 4.22164 9.87868L5.63585 8.46446L7.05007 9.87868L5.63585 11.2929C3.68323 13.2455 3.68323 16.4113 5.63585 18.364C7.58847 20.3166 10.7543 20.3166 12.7069 18.364L14.1211 16.9497L15.5353 18.364ZM14.8282 7.75736L16.2425 9.17157L9.17139 16.2426L7.75717 14.8284L14.8282 7.75736Z" }, child: [] }] })(e);
}
function rn(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8.00008 6V9H5.00008V6H8.00008ZM3.00008 4V11H10.0001V4H3.00008ZM13.0001 4H21.0001V6H13.0001V4ZM13.0001 11H21.0001V13H13.0001V11ZM13.0001 18H21.0001V20H13.0001V18ZM10.7072 16.2071L9.29297 14.7929L6.00008 18.0858L4.20718 16.2929L2.79297 17.7071L6.00008 20.9142L10.7072 16.2071Z" }, child: [] }] })(e);
}
function ln(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 4H21V6H8V4ZM5 3V6H6V7H3V6H4V4H3V3H5ZM3 14V11.5H5V11H3V10H6V12.5H4V13H6V14H3ZM5 19.5H3V18.5H5V18H3V17H6V21H3V20H5V19.5ZM8 11H21V13H8V11ZM8 18H21V20H8V18Z" }, child: [] }] })(e);
}
function an(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 4H21V6H8V4ZM4.5 6.5C3.67157 6.5 3 5.82843 3 5C3 4.17157 3.67157 3.5 4.5 3.5C5.32843 3.5 6 4.17157 6 5C6 5.82843 5.32843 6.5 4.5 6.5ZM4.5 13.5C3.67157 13.5 3 12.8284 3 12C3 11.1716 3.67157 10.5 4.5 10.5C5.32843 10.5 6 11.1716 6 12C6 12.8284 5.32843 13.5 4.5 13.5ZM4.5 20.4C3.67157 20.4 3 19.7284 3 18.9C3 18.0716 3.67157 17.4 4.5 17.4C5.32843 17.4 6 18.0716 6 18.9C6 19.7284 5.32843 20.4 4.5 20.4ZM8 11H21V13H8V11ZM8 18H21V20H8V18Z" }, child: [] }] })(e);
}
function Wo(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M17.1538 14C17.3846 14.5161 17.5 15.0893 17.5 15.7196C17.5 17.0625 16.9762 18.1116 15.9286 18.867C14.8809 19.6223 13.4335 20 11.5862 20C9.94674 20 8.32335 19.6185 6.71592 18.8555V16.6009C8.23538 17.4783 9.7908 17.917 11.3822 17.917C13.9333 17.917 15.2128 17.1846 15.2208 15.7196C15.2208 15.0939 15.0049 14.5598 14.5731 14.1173C14.5339 14.0772 14.4939 14.0381 14.4531 14H3V12H21V14H17.1538ZM13.076 11H7.62908C7.4566 10.8433 7.29616 10.6692 7.14776 10.4778C6.71592 9.92084 6.5 9.24559 6.5 8.45207C6.5 7.21602 6.96583 6.165 7.89749 5.299C8.82916 4.43299 10.2706 4 12.2219 4C13.6934 4 15.1009 4.32808 16.4444 4.98426V7.13591C15.2448 6.44921 13.9293 6.10587 12.4978 6.10587C10.0187 6.10587 8.77917 6.88793 8.77917 8.45207C8.77917 8.87172 8.99709 9.23796 9.43293 9.55079C9.86878 9.86362 10.4066 10.1135 11.0463 10.3004C11.6665 10.4816 12.3431 10.7148 13.076 11H13.076Z" }, child: [] }] })(e);
}
function Go(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M13 10V14H19V10H13ZM11 10H5V14H11V10ZM13 19H19V16H13V19ZM11 19V16H5V19H11ZM13 5V8H19V5H13ZM11 5H5V8H11V5ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3Z" }, child: [] }] })(e);
}
function Xe(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M13 6V21H11V6H5V4H19V6H13Z" }, child: [] }] })(e);
}
function $o(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 3V12C8 14.2091 9.79086 16 12 16C14.2091 16 16 14.2091 16 12V3H18V12C18 15.3137 15.3137 18 12 18C8.68629 18 6 15.3137 6 12V3H8ZM4 20H20V22H4V20Z" }, child: [] }] })(e);
}
function qo(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M2 3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082C21.556 3 22 3.44495 22 3.9934V20.0066C22 20.5552 21.5447 21 21.0082 21H2.9918C2.44405 21 2 20.5551 2 20.0066V3.9934ZM8 5V19H16V5H8ZM4 5V7H6V5H4ZM18 5V7H20V5H18ZM4 9V11H6V9H4ZM18 9V11H20V9H18ZM4 13V15H6V13H4ZM18 13V15H20V13H18ZM4 17V19H6V17H4ZM18 17V19H20V17H18Z" }, child: [] }] })(e);
}
function cn(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M5 11.1005L7 9.1005L12.5 14.6005L16 11.1005L19 14.1005V5H5V11.1005ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3ZM15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10Z" }, child: [] }] })(e);
}
function Yo(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M21 15V18H24V20H21V23H19V20H16V18H19V15H21ZM21.0082 3C21.556 3 22 3.44495 22 3.9934L22.0007 13.3417C21.3749 13.1204 20.7015 13 20 13V5H4L4.001 19L13.2929 9.70715C13.6528 9.34604 14.22 9.31823 14.6123 9.62322L14.7065 9.70772L18.2521 13.2586C15.791 14.0069 14 16.2943 14 19C14 19.7015 14.1204 20.3749 14.3417 21.0007L2.9918 21C2.44405 21 2 20.5551 2 20.0066V3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082ZM8 7C9.10457 7 10 7.89543 10 9C10 10.1046 9.10457 11 8 11C6.89543 11 6 10.1046 6 9C6 7.89543 6.89543 7 8 7Z" }, child: [] }] })(e);
}
function Ko(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M20 3C20.5523 3 21 3.44772 21 4V5.757L19 7.757V5H5V13.1L9 9.1005L13.328 13.429L12.0012 14.7562L11.995 18.995L16.2414 19.0012L17.571 17.671L18.8995 19H19V16.242L21 14.242V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H20ZM21.7782 7.80761L23.1924 9.22183L15.4142 17L13.9979 16.9979L14 15.5858L21.7782 7.80761ZM15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7Z" }, child: [] }] })(e);
}
function Xo(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 3.9934C3 3.44476 3.44495 3 3.9934 3H20.0066C20.5552 3 21 3.44495 21 3.9934V20.0066C21 20.5552 20.5551 21 20.0066 21H3.9934C3.44476 21 3 20.5551 3 20.0066V3.9934ZM10.6219 8.41459C10.5562 8.37078 10.479 8.34741 10.4 8.34741C10.1791 8.34741 10 8.52649 10 8.74741V15.2526C10 15.3316 10.0234 15.4088 10.0672 15.4745C10.1897 15.6583 10.4381 15.708 10.6219 15.5854L15.5008 12.3328C15.5447 12.3035 15.5824 12.2658 15.6117 12.2219C15.7343 12.0381 15.6846 11.7897 15.5008 11.6672L10.6219 8.41459Z" }, child: [] }] })(e);
}
function sn(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M2 16.0001H5.88889L11.1834 20.3319C11.2727 20.405 11.3846 20.4449 11.5 20.4449C11.7761 20.4449 12 20.2211 12 19.9449V4.05519C12 3.93977 11.9601 3.8279 11.887 3.73857C11.7121 3.52485 11.3971 3.49335 11.1834 3.66821L5.88889 8.00007H2C1.44772 8.00007 1 8.44778 1 9.00007V15.0001C1 15.5524 1.44772 16.0001 2 16.0001ZM23 12C23 15.292 21.5539 18.2463 19.2622 20.2622L17.8445 18.8444C19.7758 17.1937 21 14.7398 21 12C21 9.26016 19.7758 6.80629 17.8445 5.15557L19.2622 3.73779C21.5539 5.75368 23 8.70795 23 12ZM18 12C18 10.0883 17.106 8.38548 15.7133 7.28673L14.2842 8.71584C15.3213 9.43855 16 10.64 16 12C16 13.36 15.3213 14.5614 14.2842 15.2841L15.7133 16.7132C17.106 15.6145 18 13.9116 18 12Z" }, child: [] }] })(e);
}
function Jo(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M17 6H22V8H20V21C20 21.5523 19.5523 22 19 22H5C4.44772 22 4 21.5523 4 21V8H2V6H7V3C7 2.44772 7.44772 2 8 2H16C16.5523 2 17 2.44772 17 3V6ZM18 8H6V20H18V8ZM9 4V6H15V4H9Z" }, child: [] }] })(e);
}
function Qo(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M4 19H20V12H22V20C22 20.5523 21.5523 21 21 21H3C2.44772 21 2 20.5523 2 20V12H4V19ZM14 9H19L12 16L5 9H10V3H14V9Z" }, child: [] }] })(e);
}
function er(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M10 6V8H5V19H16V14H18V20C18 20.5523 17.5523 21 17 21H4C3.44772 21 3 20.5523 3 20V7C3 6.44772 3.44772 6 4 6H10ZM21 3V12L17.206 8.207L11.2071 14.2071L9.79289 12.7929L15.792 6.793L12 3H21Z" }, child: [] }] })(e);
}
function tr(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM8 13C8 15.2091 9.79086 17 12 17C14.2091 17 16 15.2091 16 13H8ZM8 11C8.82843 11 9.5 10.3284 9.5 9.5C9.5 8.67157 8.82843 8 8 8C7.17157 8 6.5 8.67157 6.5 9.5C6.5 10.3284 7.17157 11 8 11ZM16 11C16.8284 11 17.5 10.3284 17.5 9.5C17.5 8.67157 16.8284 8 16 8C15.1716 8 14.5 8.67157 14.5 9.5C14.5 10.3284 15.1716 11 16 11Z" }, child: [] }] })(e);
}
function D2(e) {
  const t = z2();
  if (e || (e = t == null ? void 0 : t.editor), !e)
    throw new Error(
      "'editor' is required, either from BlockNoteContext or as a function argument"
    );
  const n = e, [o, l2] = (0, import_react2.useState)(() => {
    var a;
    return ((a = n.getSelection()) == null ? void 0 : a.blocks) || [n.getTextCursorPosition().block];
  });
  return W(
    () => {
      var a;
      return l2(
        ((a = n.getSelection()) == null ? void 0 : a.blocks) || [n.getTextCursorPosition().block]
      );
    },
    n
  ), o;
}
function V() {
  return z2().editor.dictionary;
}
var nr = {
  bold: Do,
  italic: Uo,
  underline: $o,
  strike: Wo,
  code: Po
};
function or(e, t) {
  return e in t.schema.styleSchema && t.schema.styleSchema[e].type === e && t.schema.styleSchema[e].propSchema === "boolean";
}
var be = (e) => {
  const t = V(), n = C(), o = H(), l2 = or(
    e.basicTextStyle,
    o
  ), a = D2(o), [c, u] = (0, import_react2.useState)(
    e.basicTextStyle in o.getActiveStyles()
  );
  W(() => {
    l2 && u(e.basicTextStyle in o.getActiveStyles());
  }, o);
  const d = (g) => {
    if (o.focus(), !!l2) {
      if (o.schema.styleSchema[g].propSchema !== "boolean")
        throw new Error("can only toggle boolean styles");
      o.toggleStyles({ [g]: true });
    }
  };
  if (!(0, import_react2.useMemo)(() => l2 ? !!a.find((g) => g.content !== void 0) : false, [l2, a]) || !o.isEditable)
    return null;
  const m = nr[e.basicTextStyle];
  return r.jsx(
    n.FormattingToolbar.Button,
    {
      className: "bn-button",
      "data-test": e.basicTextStyle,
      onClick: () => d(e.basicTextStyle),
      isSelected: c,
      label: t.formatting_toolbar[e.basicTextStyle].tooltip,
      mainTooltip: t.formatting_toolbar[e.basicTextStyle].tooltip,
      secondaryTooltip: D(
        t.formatting_toolbar[e.basicTextStyle].secondary_tooltip,
        t.generic.ctrl_shortcut
      ),
      icon: r.jsx(m, {})
    }
  );
};
var Ge = (e) => {
  const t = e.textColor || "default", n = e.backgroundColor || "default", o = e.size || 16, l2 = (0, import_react2.useMemo)(
    () => ({
      pointerEvents: "none",
      fontSize: (o * 0.75).toString() + "px",
      height: o.toString() + "px",
      lineHeight: o.toString() + "px",
      textAlign: "center",
      width: o.toString() + "px"
    }),
    [o]
  );
  return r.jsx(
    "div",
    {
      className: "bn-color-icon",
      "data-background-color": n,
      "data-text-color": t,
      style: l2,
      children: "A"
    }
  );
};
var Tt = [
  "default",
  "gray",
  "brown",
  "red",
  "orange",
  "yellow",
  "green",
  "blue",
  "purple",
  "pink"
];
var un = (e) => {
  const t = C(), n = V(), o = () => e.text ? r.jsxs(r.Fragment, { children: [
    r.jsx(t.Generic.Menu.Label, { children: n.color_picker.text_title }),
    Tt.map((a) => r.jsx(
      t.Generic.Menu.Item,
      {
        onClick: () => {
          e.onClick && e.onClick(), e.text.setColor(a);
        },
        "data-test": "text-color-" + a,
        icon: r.jsx(Ge, { textColor: a, size: e.iconSize }),
        checked: e.text.color === a,
        children: n.color_picker.colors[a]
      },
      "text-color-" + a
    ))
  ] }) : null, l2 = () => e.background ? r.jsxs(r.Fragment, { children: [
    r.jsx(t.Generic.Menu.Label, { children: n.color_picker.background_title }),
    Tt.map((a) => r.jsx(
      t.Generic.Menu.Item,
      {
        onClick: () => {
          e.onClick && e.onClick(), e.background.setColor(a);
        },
        "data-test": "background-color-" + a,
        icon: r.jsx(Ge, { backgroundColor: a, size: e.iconSize }),
        checked: e.background.color === a,
        children: n.color_picker.colors[a]
      },
      "background-color-" + a
    ))
  ] }) : null;
  return r.jsxs(r.Fragment, { children: [
    r.jsx(o, {}),
    r.jsx(l2, {})
  ] });
};
function Lt(e, t) {
  return `${e}Color` in t.schema.styleSchema && t.schema.styleSchema[`${e}Color`].type === `${e}Color` && t.schema.styleSchema[`${e}Color`].propSchema === "string";
}
var rr = () => {
  const e = C(), t = V(), n = H(), o = Lt("text", n), l2 = Lt("background", n), a = D2(n), [c, u] = (0, import_react2.useState)(
    o && n.getActiveStyles().textColor || "default"
  ), [d, s] = (0, import_react2.useState)(
    l2 && n.getActiveStyles().backgroundColor || "default"
  );
  W(() => {
    o && u(n.getActiveStyles().textColor || "default"), l2 && s(
      n.getActiveStyles().backgroundColor || "default"
    );
  }, n);
  const m = (0, import_react2.useCallback)(
    (v) => {
      if (!o)
        throw Error(
          "Tried to set text color, but style does not exist in editor schema."
        );
      v === "default" ? n.removeStyles({ textColor: v }) : n.addStyles({ textColor: v }), setTimeout(() => {
        n.focus();
      });
    },
    [n, o]
  ), g = (0, import_react2.useCallback)(
    (v) => {
      if (!l2)
        throw Error(
          "Tried to set background color, but style does not exist in editor schema."
        );
      v === "default" ? n.removeStyles({ backgroundColor: v }) : n.addStyles({ backgroundColor: v }), setTimeout(() => {
        n.focus();
      });
    },
    [l2, n]
  );
  return !(0, import_react2.useMemo)(() => {
    if (!o && !l2)
      return false;
    for (const v of a)
      if (v.content !== void 0)
        return true;
    return false;
  }, [l2, a, o]) || !n.isEditable ? null : r.jsxs(e.Generic.Menu.Root, { children: [
    r.jsx(e.Generic.Menu.Trigger, { children: r.jsx(
      e.FormattingToolbar.Button,
      {
        className: "bn-button",
        "data-test": "colors",
        label: t.formatting_toolbar.colors.tooltip,
        mainTooltip: t.formatting_toolbar.colors.tooltip,
        icon: r.jsx(
          Ge,
          {
            textColor: c,
            backgroundColor: d,
            size: 20
          }
        )
      }
    ) }),
    r.jsx(
      e.Generic.Menu.Dropdown,
      {
        className: "bn-menu-dropdown bn-color-picker-dropdown",
        children: r.jsx(
          un,
          {
            text: o ? {
              color: c,
              setColor: m
            } : void 0,
            background: l2 ? {
              color: d,
              setColor: g
            } : void 0
          }
        )
      }
    )
  ] });
};
var dn = (e) => {
  const t = C(), n = V(), { url: o, text: l2, editLink: a } = e, [c, u] = (0, import_react2.useState)(o), [d, s] = (0, import_react2.useState)(l2);
  (0, import_react2.useEffect)(() => {
    u(o), s(l2);
  }, [l2, o]);
  const m = (0, import_react2.useCallback)(
    (E) => {
      E.key === "Enter" && (E.preventDefault(), a(c, d));
    },
    [a, c, d]
  ), g = (0, import_react2.useCallback)(
    (E) => u(E.currentTarget.value),
    []
  ), h = (0, import_react2.useCallback)(
    (E) => s(E.currentTarget.value),
    []
  ), v = (0, import_react2.useCallback)(
    () => a(c, d),
    [a, c, d]
  );
  return r.jsxs(t.Generic.Form.Root, { children: [
    r.jsx(
      t.Generic.Form.TextInput,
      {
        className: "bn-text-input",
        name: "url",
        icon: r.jsx(on, {}),
        autoFocus: true,
        placeholder: n.link_toolbar.form.url_placeholder,
        value: c,
        onKeyDown: m,
        onChange: g,
        onSubmit: v
      }
    ),
    r.jsx(
      t.Generic.Form.TextInput,
      {
        className: "bn-text-input",
        name: "title",
        icon: r.jsx(Xe, {}),
        placeholder: n.link_toolbar.form.title_placeholder,
        value: d,
        onKeyDown: m,
        onChange: h,
        onSubmit: v
      }
    )
  ] });
};
function ir(e) {
  return "link" in e.schema.inlineContentSchema && e.schema.inlineContentSchema.link === "link";
}
var lr = () => {
  const e = H(), t = C(), n = V(), o = ir(e), l2 = D2(e), [a, c] = (0, import_react2.useState)(e.getSelectedLinkUrl() || ""), [u, d] = (0, import_react2.useState)(e.getSelectedText());
  W(() => {
    d(e.getSelectedText() || ""), c(e.getSelectedLinkUrl() || "");
  }, e);
  const s = (0, import_react2.useCallback)(
    (g, h) => {
      e.createLink(g, h), e.focus();
    },
    [e]
  );
  return !(0, import_react2.useMemo)(() => {
    if (!o)
      return false;
    for (const g of l2)
      if (g.content === void 0)
        return false;
    return true;
  }, [o, l2]) || !("link" in e.schema.inlineContentSchema) || !e.isEditable ? null : r.jsxs(t.Generic.Popover.Root, { children: [
    r.jsx(t.Generic.Popover.Trigger, { children: r.jsx(
      t.FormattingToolbar.Button,
      {
        className: "bn-button",
        "data-test": "createLink",
        label: n.formatting_toolbar.link.tooltip,
        mainTooltip: n.formatting_toolbar.link.tooltip,
        secondaryTooltip: D(
          n.formatting_toolbar.link.secondary_tooltip,
          n.generic.ctrl_shortcut
        ),
        icon: r.jsx(on, {})
      }
    ) }),
    r.jsx(
      t.Generic.Popover.Content,
      {
        className: "bn-popover-content bn-form-popover",
        variant: "form-popover",
        children: r.jsx(dn, { url: a, text: u, editLink: s })
      }
    )
  ] });
};
var ar = () => {
  const e = V(), t = C(), n = H(), [o, l2] = (0, import_react2.useState)(), a = D2(n), c = (0, import_react2.useMemo)(() => {
    if (a.length !== 1)
      return;
    const s = a[0];
    if (Ir(s, n))
      return l2(s.props.caption), s;
  }, [n, a]), u = (0, import_react2.useCallback)(
    (s) => {
      c && s.key === "Enter" && (s.preventDefault(), n.updateBlock(c, {
        props: {
          caption: o
          // TODO
        }
      }));
    },
    [o, n, c]
  ), d = (0, import_react2.useCallback)(
    (s) => l2(s.currentTarget.value),
    []
  );
  return !c || Nr(c, n) || !n.isEditable ? null : r.jsxs(t.Generic.Popover.Root, { children: [
    r.jsx(t.Generic.Popover.Trigger, { children: r.jsx(
      t.FormattingToolbar.Button,
      {
        className: "bn-button",
        label: e.formatting_toolbar.file_caption.tooltip,
        mainTooltip: e.formatting_toolbar.file_caption.tooltip,
        icon: r.jsx(Et, {}),
        isSelected: c.props.caption !== ""
      }
    ) }),
    r.jsx(
      t.Generic.Popover.Content,
      {
        className: "bn-popover-content bn-form-popover",
        variant: "form-popover",
        children: r.jsx(t.Generic.Form.Root, { children: r.jsx(
          t.Generic.Form.TextInput,
          {
            name: "file-caption",
            icon: r.jsx(Et, {}),
            value: o || "",
            autoFocus: true,
            placeholder: e.formatting_toolbar.file_caption.input_placeholder,
            onKeyDown: u,
            onChange: d
          }
        ) })
      }
    )
  ] });
};
var cr = () => {
  const e = V(), t = C(), n = H(), o = D2(n), [l2, a] = (0, import_react2.useState)(
    () => n.canNestBlock()
  );
  W(() => {
    a(n.canNestBlock());
  }, n);
  const c = (0, import_react2.useCallback)(() => {
    n.focus(), n.nestBlock();
  }, [n]);
  return !(0, import_react2.useMemo)(() => !o.find(
    (d) => n.schema.blockSchema[d.type].content !== "inline"
  ), [n.schema.blockSchema, o]) || !n.isEditable ? null : r.jsx(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      "data-test": "nestBlock",
      onClick: c,
      isDisabled: !l2,
      label: e.formatting_toolbar.nest.tooltip,
      mainTooltip: e.formatting_toolbar.nest.tooltip,
      secondaryTooltip: D(
        e.formatting_toolbar.nest.secondary_tooltip,
        e.generic.ctrl_shortcut
      ),
      icon: r.jsx(Zo, {})
    }
  );
};
var sr = () => {
  const e = V(), t = C(), n = H(), o = D2(n), [l2, a] = (0, import_react2.useState)(
    () => n.canUnnestBlock()
  );
  W(() => {
    a(n.canUnnestBlock());
  }, n);
  const c = (0, import_react2.useCallback)(() => {
    n.focus(), n.unnestBlock();
  }, [n]);
  return !(0, import_react2.useMemo)(() => !o.find(
    (d) => n.schema.blockSchema[d.type].content !== "inline"
  ), [n.schema.blockSchema, o]) || !n.isEditable ? null : r.jsx(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      "data-test": "unnestBlock",
      onClick: c,
      isDisabled: !l2,
      label: e.formatting_toolbar.unnest.tooltip,
      mainTooltip: e.formatting_toolbar.unnest.tooltip,
      secondaryTooltip: D(
        e.formatting_toolbar.unnest.secondary_tooltip,
        e.generic.ctrl_shortcut
      ),
      icon: r.jsx(Ao, {})
    }
  );
};
var ur = (e) => {
  const t = C(), n = V(), { block: o } = e, l2 = H(), [a, c] = (0, import_react2.useState)(""), u = (0, import_react2.useCallback)(
    (m) => {
      c(m.currentTarget.value);
    },
    []
  ), d = (0, import_react2.useCallback)(
    (m) => {
      m.key === "Enter" && (m.preventDefault(), l2.updateBlock(o, {
        props: {
          name: Sr(a),
          url: a
        }
      }));
    },
    [l2, o, a]
  ), s = (0, import_react2.useCallback)(() => {
    l2.updateBlock(o, {
      props: {
        name: Sr(a),
        url: a
      }
    });
  }, [l2, o, a]);
  return r.jsxs(t.FilePanel.TabPanel, { className: "bn-tab-panel", children: [
    r.jsx(
      t.FilePanel.TextInput,
      {
        className: "bn-text-input",
        placeholder: n.file_panel.embed.url_placeholder,
        value: a,
        onChange: u,
        onKeyDown: d,
        "data-test": "embed-input"
      }
    ),
    r.jsx(
      t.FilePanel.Button,
      {
        className: "bn-button",
        onClick: s,
        "data-test": "embed-input-button",
        children: n.file_panel.embed.embed_button[o.type] || n.file_panel.embed.embed_button.file
      }
    )
  ] });
};
var dr = (e) => {
  var g;
  const t = C(), n = V(), { block: o, setLoading: l2 } = e, a = H(), [c, u] = (0, import_react2.useState)(false);
  (0, import_react2.useEffect)(() => {
    c && setTimeout(() => {
      u(false);
    }, 3e3);
  }, [c]);
  const d = (0, import_react2.useCallback)(
    (h) => {
      if (h === null)
        return;
      async function v(E) {
        if (l2(true), a.uploadFile !== void 0)
          try {
            let B = await a.uploadFile(E);
            typeof B == "string" && (B = {
              props: {
                name: E.name,
                url: B
              }
            }), a.updateBlock(o, B);
          } catch {
            u(true);
          } finally {
            l2(false);
          }
      }
      v(h);
    },
    [o, a, l2]
  ), s = a.schema.blockSchema[o.type], m = s.isFileBlock && ((g = s.fileBlockAccept) != null && g.length) ? s.fileBlockAccept.join(",") : "*/*";
  return r.jsxs(t.FilePanel.TabPanel, { className: "bn-tab-panel", children: [
    r.jsx(
      t.FilePanel.FileInput,
      {
        className: "bn-file-input",
        "data-test": "upload-input",
        accept: m,
        placeholder: n.file_panel.upload.file_placeholder[o.type] || n.file_panel.upload.file_placeholder.file,
        value: null,
        onChange: d
      }
    ),
    c && r.jsx("div", { className: "bn-error-text", children: n.file_panel.upload.upload_error })
  ] });
};
var fn2 = (e) => {
  const t = C(), n = V(), o = H(), [l2, a] = (0, import_react2.useState)(false), c = e.tabs ?? [
    ...o.uploadFile !== void 0 ? [
      {
        name: n.file_panel.upload.title,
        tabPanel: r.jsx(dr, { block: e.block, setLoading: a })
      }
    ] : [],
    {
      name: n.file_panel.embed.title,
      tabPanel: r.jsx(ur, { block: e.block })
    }
  ], [u, d] = (0, import_react2.useState)(
    e.defaultOpenTab || c[0].name
  );
  return r.jsx(
    t.FilePanel.Root,
    {
      className: "bn-panel",
      defaultOpenTab: u,
      openTab: u,
      setOpenTab: d,
      tabs: c,
      loading: l2
    }
  );
};
var fr = () => {
  const e = V(), t = C(), n = H(), o = D2(n), [l2, a] = (0, import_react2.useState)(false);
  (0, import_react2.useEffect)(() => {
    a(false);
  }, [o]);
  const c = o.length === 1 ? o[0] : void 0;
  return c === void 0 || !Ir(c, n) || !n.isEditable ? null : r.jsxs(t.Generic.Popover.Root, { opened: l2, position: "bottom", children: [
    r.jsx(t.Generic.Popover.Trigger, { children: r.jsx(
      t.FormattingToolbar.Button,
      {
        className: "bn-button",
        onClick: () => a(!l2),
        isSelected: l2,
        mainTooltip: e.formatting_toolbar.file_replace.tooltip[c.type] || e.formatting_toolbar.file_replace.tooltip.file,
        label: e.formatting_toolbar.file_replace.tooltip[c.type] || e.formatting_toolbar.file_replace.tooltip.file,
        icon: r.jsx(Ko, {})
      }
    ) }),
    r.jsx(
      t.Generic.Popover.Content,
      {
        className: "bn-popover-content bn-panel-popover",
        variant: "panel-popover",
        children: r.jsx(fn2, { block: c })
      }
    )
  ] });
};
var gr = {
  left: No,
  center: Oo,
  right: Io,
  justify: Fo
};
var Ze = (e) => {
  const t = C(), n = V(), o = H(), l2 = D2(o), a = (0, import_react2.useMemo)(() => {
    const s = l2[0];
    if (Pr("textAlignment", s, o))
      return s.props.textAlignment;
  }, [o, l2]), c = (0, import_react2.useCallback)(
    (s) => {
      o.focus();
      for (const m of l2)
        Vo("textAlignment", m.type, o) && o.updateBlock(m, {
          props: { textAlignment: s }
        });
    },
    [o, l2]
  );
  if (!(0, import_react2.useMemo)(() => !!l2.find((s) => "textAlignment" in s.props), [l2]) || !o.isEditable)
    return null;
  const d = gr[e.textAlignment];
  return r.jsx(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      "data-test": `alignText${e.textAlignment.slice(0, 1).toUpperCase() + e.textAlignment.slice(1)}`,
      onClick: () => c(e.textAlignment),
      isSelected: a === e.textAlignment,
      label: n.formatting_toolbar[`align_${e.textAlignment}`].tooltip,
      mainTooltip: n.formatting_toolbar[`align_${e.textAlignment}`].tooltip,
      icon: r.jsx(d, {})
    }
  );
};
var mr = (e) => [
  {
    name: e.slash_menu.paragraph.title,
    type: "paragraph",
    icon: Xe,
    isSelected: (t) => t.type === "paragraph"
  },
  {
    name: e.slash_menu.heading.title,
    type: "heading",
    props: { level: 1 },
    icon: en,
    isSelected: (t) => t.type === "heading" && "level" in t.props && t.props.level === 1
  },
  {
    name: e.slash_menu.heading_2.title,
    type: "heading",
    props: { level: 2 },
    icon: tn,
    isSelected: (t) => t.type === "heading" && "level" in t.props && t.props.level === 2
  },
  {
    name: e.slash_menu.heading_3.title,
    type: "heading",
    props: { level: 3 },
    icon: nn,
    isSelected: (t) => t.type === "heading" && "level" in t.props && t.props.level === 3
  },
  {
    name: e.slash_menu.bullet_list.title,
    type: "bulletListItem",
    icon: an,
    isSelected: (t) => t.type === "bulletListItem"
  },
  {
    name: e.slash_menu.numbered_list.title,
    type: "numberedListItem",
    icon: ln,
    isSelected: (t) => t.type === "numberedListItem"
  },
  {
    name: e.slash_menu.check_list.title,
    type: "checkListItem",
    icon: rn,
    isSelected: (t) => t.type === "checkListItem"
  }
];
var hr = (e) => {
  const t = C(), n = V(), o = H(), l2 = D2(o), [a, c] = (0, import_react2.useState)(o.getTextCursorPosition().block), u = (0, import_react2.useMemo)(() => (e.items || mr(n)).filter(
    (m) => m.type in o.schema.blockSchema
  ), [o, n, e.items]), d = (0, import_react2.useMemo)(
    () => u.find((m) => m.type === a.type) !== void 0,
    [a.type, u]
  ), s = (0, import_react2.useMemo)(() => {
    const m = (g) => {
      o.focus();
      for (const h of l2)
        o.updateBlock(h, {
          type: g.type,
          props: g.props
        });
    };
    return u.map((g) => {
      const h = g.icon;
      return {
        text: g.name,
        icon: r.jsx(h, { size: 16 }),
        onClick: () => m(g),
        isSelected: g.isSelected(a)
      };
    });
  }, [a, u, o, l2]);
  return W(() => {
    c(o.getTextCursorPosition().block);
  }, o), !d || !o.isEditable ? null : r.jsx(
    t.FormattingToolbar.Select,
    {
      className: "bn-select",
      items: s
    }
  );
};
var br = () => {
  const e = V(), t = C(), n = H(), [o, l2] = (0, import_react2.useState)(), a = D2(n), c = (0, import_react2.useMemo)(() => {
    if (a.length !== 1)
      return;
    const s = a[0];
    if (Ir(s, n))
      return l2(s.props.name), s;
  }, [n, a]), u = (0, import_react2.useCallback)(
    (s) => {
      c && s.key === "Enter" && (s.preventDefault(), n.updateBlock(c, {
        props: {
          name: o
          // TODO
        }
      }));
    },
    [o, n, c]
  ), d = (0, import_react2.useCallback)(
    (s) => l2(s.currentTarget.value),
    []
  );
  return !c || Nr(c, n) || !n.isEditable ? null : r.jsxs(t.Generic.Popover.Root, { children: [
    r.jsx(t.Generic.Popover.Trigger, { children: r.jsx(
      t.FormattingToolbar.Button,
      {
        className: "bn-button",
        label: e.formatting_toolbar.file_rename.tooltip[c.type] || e.formatting_toolbar.file_rename.tooltip.file,
        mainTooltip: e.formatting_toolbar.file_rename.tooltip[c.type] || e.formatting_toolbar.file_rename.tooltip.file,
        icon: r.jsx(Vt, {})
      }
    ) }),
    r.jsx(
      t.Generic.Popover.Content,
      {
        className: "bn-popover-content bn-form-popover",
        variant: "form-popover",
        children: r.jsx(t.Generic.Form.Root, { children: r.jsx(
          t.Generic.Form.TextInput,
          {
            name: "file-name",
            icon: r.jsx(Vt, {}),
            value: o || "",
            autoFocus: true,
            placeholder: e.formatting_toolbar.file_rename.input_placeholder[c.type] || e.formatting_toolbar.file_rename.input_placeholder.file,
            onKeyDown: u,
            onChange: d
          }
        ) })
      }
    )
  ] });
};
var pr = () => {
  const e = V(), t = C(), n = H(), o = D2(n), l2 = (0, import_react2.useMemo)(() => {
    if (o.length !== 1)
      return;
    const c = o[0];
    if (Ir(c, n))
      return c;
  }, [n, o]), a = (0, import_react2.useCallback)(() => {
    l2 && l2.props.url && (n.focus(), n.resolveFileUrl(l2.props.url).then((c) => window.open(c)));
  }, [n, l2]);
  return !l2 || Nr(l2, n) ? null : r.jsx(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      label: e.formatting_toolbar.file_download.tooltip[l2.type] || e.formatting_toolbar.file_download.tooltip.file,
      mainTooltip: e.formatting_toolbar.file_download.tooltip[l2.type] || e.formatting_toolbar.file_download.tooltip.file,
      icon: r.jsx(Qo, {}),
      onClick: a
    }
  );
};
var xr = () => {
  const e = V(), t = C(), n = H(), o = D2(n), l2 = (0, import_react2.useMemo)(() => {
    if (o.length !== 1)
      return;
    const c = o[0];
    if (Ar(c, n))
      return c;
  }, [n, o]), a = (0, import_react2.useCallback)(() => {
    l2 && n.updateBlock(l2, {
      props: {
        showPreview: !l2.props.showPreview
        // TODO
      }
    });
  }, [n, l2]);
  return !l2 || Nr(l2, n) || !n.isEditable ? null : r.jsx(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      label: "Toggle preview",
      mainTooltip: e.formatting_toolbar.file_preview_toggle.tooltip,
      icon: r.jsx(Yo, {}),
      isSelected: l2.props.showPreview,
      onClick: a
    }
  );
};
var vr = () => {
  const e = V(), t = C(), n = H(), o = D2(n), l2 = (0, import_react2.useMemo)(() => {
    if (o.length !== 1)
      return;
    const c = o[0];
    if (Ir(c, n))
      return c;
  }, [n, o]), a = (0, import_react2.useCallback)(() => {
    n.focus(), n.removeBlocks([l2]);
  }, [n, l2]);
  return !l2 || Nr(l2, n) || !n.isEditable ? null : r.jsx(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      label: e.formatting_toolbar.file_delete.tooltip[l2.type] || e.formatting_toolbar.file_delete.tooltip.file,
      mainTooltip: e.formatting_toolbar.file_delete.tooltip[l2.type] || e.formatting_toolbar.file_delete.tooltip.file,
      icon: r.jsx(Jo, {}),
      onClick: a
    }
  );
};
var Cr2 = (e) => [
  r.jsx(hr, { items: e }, "blockTypeSelect"),
  r.jsx(ar, {}, "fileCaptionButton"),
  r.jsx(fr, {}, "replaceFileButton"),
  r.jsx(br, {}, "fileRenameButton"),
  r.jsx(vr, {}, "fileDeleteButton"),
  r.jsx(pr, {}, "fileDownloadButton"),
  r.jsx(xr, {}, "filePreviewButton"),
  r.jsx(be, { basicTextStyle: "bold" }, "boldStyleButton"),
  r.jsx(be, { basicTextStyle: "italic" }, "italicStyleButton"),
  r.jsx(
    be,
    {
      basicTextStyle: "underline"
    },
    "underlineStyleButton"
  ),
  r.jsx(be, { basicTextStyle: "strike" }, "strikeStyleButton"),
  r.jsx(Ze, { textAlignment: "left" }, "textAlignLeftButton"),
  r.jsx(Ze, { textAlignment: "center" }, "textAlignCenterButton"),
  r.jsx(Ze, { textAlignment: "right" }, "textAlignRightButton"),
  r.jsx(rr, {}, "colorStyleButton"),
  r.jsx(cr, {}, "nestBlockButton"),
  r.jsx(sr, {}, "unnestBlockButton"),
  r.jsx(lr, {}, "createLinkButton")
];
var kr = (e) => {
  const t = C();
  return r.jsx(
    t.FormattingToolbar.Root,
    {
      className: "bn-toolbar bn-formatting-toolbar",
      children: e.children || Cr2(e.blockTypeSelectItems)
    }
  );
};
var Rt = (e) => {
  switch (e) {
    case "left":
      return "top-start";
    case "center":
      return "top";
    case "right":
      return "top-end";
    default:
      return "top-start";
  }
};
var yr = (e) => {
  const t = (0, import_react2.useRef)(null), n = H(), [o, l2] = (0, import_react2.useState)(
    () => {
      const h = n.getTextCursorPosition().block;
      return "textAlignment" in h.props ? Rt(
        h.props.textAlignment
      ) : "top-start";
    }
  );
  W(() => {
    const h = n.getTextCursorPosition().block;
    "textAlignment" in h.props ? l2(
      Rt(
        h.props.textAlignment
      )
    ) : l2("top-start");
  }, n);
  const a = K(
    n.formattingToolbar.onUpdate.bind(n.formattingToolbar)
  ), { isMounted: c, ref: u, style: d, getFloatingProps: s } = ee(
    (a == null ? void 0 : a.show) || false,
    (a == null ? void 0 : a.referencePos) || null,
    3e3,
    {
      placement: o,
      middleware: [offset(10), flip()],
      onOpenChange: (h, v) => {
        h || (n.formattingToolbar.closeMenu(), n.focus());
      }
    }
  ), m = (0, import_react2.useMemo)(() => So([t, u]), [t, u]);
  if (!c || !a)
    return null;
  if (!a.show && t.current)
    return r.jsx(
      "div",
      {
        ref: m,
        style: d,
        dangerouslySetInnerHTML: { __html: t.current.innerHTML }
      }
    );
  const g = e.formattingToolbar || kr;
  return r.jsx("div", { ref: m, style: d, ...s(), children: r.jsx(g, {}) });
};
var jr2 = (e) => {
  const t = C(), n = V();
  return r.jsx(
    t.LinkToolbar.Button,
    {
      className: "bn-button",
      label: n.link_toolbar.delete.tooltip,
      mainTooltip: n.link_toolbar.delete.tooltip,
      isSelected: false,
      onClick: e.deleteLink,
      icon: r.jsx(zo, {})
    }
  );
};
var wr = (e) => {
  const t = C(), n = V();
  return r.jsxs(t.Generic.Popover.Root, { children: [
    r.jsx(t.Generic.Popover.Trigger, { children: r.jsx(
      t.LinkToolbar.Button,
      {
        className: "bn-button",
        mainTooltip: n.link_toolbar.edit.tooltip,
        isSelected: false,
        children: n.link_toolbar.edit.text
      }
    ) }),
    r.jsx(
      t.Generic.Popover.Content,
      {
        className: "bn-popover-content bn-form-popover",
        variant: "form-popover",
        children: r.jsx(dn, { ...e })
      }
    )
  ] });
};
var Hr = (e) => {
  const t = C(), n = V();
  return r.jsx(
    t.LinkToolbar.Button,
    {
      className: "bn-button",
      mainTooltip: n.link_toolbar.open.tooltip,
      label: n.link_toolbar.open.tooltip,
      isSelected: false,
      onClick: () => {
        window.open(e.url, "_blank");
      },
      icon: r.jsx(er, {})
    }
  );
};
var Sr2 = (e) => {
  const t = C();
  return e.children ? r.jsx(t.LinkToolbar.Root, { className: "bn-toolbar bn-link-toolbar", children: e.children }) : r.jsxs(
    t.LinkToolbar.Root,
    {
      className: "bn-toolbar bn-link-toolbar",
      onMouseEnter: e.stopHideTimer,
      onMouseLeave: e.startHideTimer,
      children: [
        r.jsx(
          wr,
          {
            url: e.url,
            text: e.text,
            editLink: e.editLink
          }
        ),
        r.jsx(Hr, { url: e.url }),
        r.jsx(jr2, { deleteLink: e.deleteLink })
      ]
    }
  );
};
var Mr = (e) => {
  const t = H(), n = {
    deleteLink: t.linkToolbar.deleteLink,
    editLink: t.linkToolbar.editLink,
    startHideTimer: t.linkToolbar.startHideTimer,
    stopHideTimer: t.linkToolbar.stopHideTimer
  }, o = K(
    t.linkToolbar.onUpdate.bind(t.linkToolbar)
  ), { isMounted: l2, ref: a, style: c, getFloatingProps: u } = ee(
    (o == null ? void 0 : o.show) || false,
    (o == null ? void 0 : o.referencePos) || null,
    4e3,
    {
      placement: "top-start",
      middleware: [offset(10), flip()],
      onOpenChange: (h) => {
        h || (t.linkToolbar.closeMenu(), t.focus());
      }
    }
  );
  if (!l2 || !o)
    return null;
  const { show: d, referencePos: s, ...m } = o, g = e.linkToolbar || Sr2;
  return r.jsx("div", { ref: a, style: c, ...u(), children: r.jsx(g, { ...m, ...n }) });
};
var _r = (e) => {
  const t = H();
  if (!t.filePanel)
    throw new Error(
      "FileToolbarController can only be used when BlockNote editor schema contains file block"
    );
  const n = K(
    t.filePanel.onUpdate.bind(t.filePanel)
  ), { isMounted: o, ref: l2, style: a, getFloatingProps: c } = ee(
    (n == null ? void 0 : n.show) || false,
    (n == null ? void 0 : n.referencePos) || null,
    5e3,
    {
      placement: "bottom",
      middleware: [offset(10), flip()],
      onOpenChange: (g) => {
        g || (t.filePanel.closeMenu(), t.focus());
      }
    }
  );
  if (!o || !n)
    return null;
  const { show: u, referencePos: d, ...s } = n, m = e.filePanel || fn2;
  return r.jsx("div", { ref: l2, style: a, ...c(), children: r.jsx(m, { ...s }) });
};
function Vr(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8Z" }, child: [] }, { tag: "path", attr: { d: "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8Z" }, child: [] }] })(e);
}
var Er2 = (e) => {
  const t = C(), n = V();
  return r.jsx(
    t.SideMenu.Button,
    {
      className: "bn-button",
      label: n.side_menu.add_block_label,
      icon: r.jsx(
        Vr,
        {
          size: 24,
          onClick: e.addBlock,
          "data-test": "dragHandleAdd"
        }
      )
    }
  );
};
function gn(e) {
  return y({ tag: "svg", attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { fill: "none", d: "M0 0h24v24H0V0z" }, child: [] }, { tag: "path", attr: { d: "M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" }, child: [] }] })(e);
}
var Tr = (e) => {
  const t = C(), n = H();
  return !Vo("textColor", e.block.type, n) && !Vo("backgroundColor", e.block.type, n) ? null : r.jsxs(t.Generic.Menu.Root, { position: "right", sub: true, children: [
    r.jsx(t.Generic.Menu.Trigger, { sub: true, children: r.jsx(
      t.Generic.Menu.Item,
      {
        className: "bn-menu-item",
        subTrigger: true,
        children: e.children
      }
    ) }),
    r.jsx(
      t.Generic.Menu.Dropdown,
      {
        sub: true,
        className: "bn-menu-dropdown bn-color-picker-dropdown",
        children: r.jsx(
          un,
          {
            iconSize: 18,
            text: Vo(
              "textColor",
              e.block.type,
              n
            ) && Pr("textColor", e.block, n) ? {
              color: e.block.props.textColor,
              setColor: (o) => n.updateBlock(e.block, {
                type: e.block.type,
                props: { textColor: o }
              })
            } : void 0,
            background: Vo(
              "backgroundColor",
              e.block.type,
              n
            ) && Pr("backgroundColor", e.block, n) ? {
              color: e.block.props.backgroundColor,
              setColor: (o) => n.updateBlock(e.block, {
                props: { backgroundColor: o }
              })
            } : void 0
          }
        )
      }
    )
  ] });
};
var Lr = (e) => {
  const t = C(), n = H();
  return r.jsx(
    t.Generic.Menu.Item,
    {
      className: "bn-menu-item",
      onClick: () => n.removeBlocks([e.block]),
      children: e.children
    }
  );
};
var Rr = (e) => {
  const t = C(), n = V();
  return r.jsx(
    t.Generic.Menu.Dropdown,
    {
      className: "bn-menu-dropdown bn-drag-handle-menu",
      children: e.children || r.jsxs(r.Fragment, { children: [
        r.jsx(Lr, { ...e, children: n.drag_handle.delete_menuitem }),
        r.jsx(Tr, { ...e, children: n.drag_handle.colors_menuitem })
      ] })
    }
  );
};
var Br = (e) => {
  const t = C(), n = V(), o = e.dragHandleMenu || Rr;
  return r.jsxs(
    t.Generic.Menu.Root,
    {
      onOpenChange: (l2) => {
        l2 ? e.freezeMenu() : (e.unfreezeMenu(), e.editor.focus());
      },
      position: "left",
      children: [
        r.jsx(t.Generic.Menu.Trigger, { children: r.jsx(
          t.SideMenu.Button,
          {
            label: n.side_menu.drag_handle_label,
            draggable: true,
            onDragStart: e.blockDragStart,
            onDragEnd: e.blockDragEnd,
            className: "bn-button",
            icon: r.jsx(gn, { size: 24, "data-test": "dragHandle" })
          }
        ) }),
        r.jsx(o, { block: e.block })
      ]
    }
  );
};
var Pr2 = (e) => {
  const t = C(), { addBlock: n, ...o } = e, l2 = (0, import_react2.useMemo)(() => {
    const a = {
      "data-block-type": e.block.type
    };
    return e.block.type === "heading" && (a["data-level"] = e.block.props.level.toString()), e.editor.schema.blockSchema[e.block.type].isFileBlock && (e.block.props.url ? a["data-url"] = "true" : a["data-url"] = "false"), a;
  }, [e.block, e.editor.schema.blockSchema]);
  return r.jsx(t.SideMenu.Root, { className: "bn-side-menu", ...l2, children: e.children || r.jsxs(r.Fragment, { children: [
    r.jsx(Er2, { addBlock: n }),
    r.jsx(Br, { ...o })
  ] }) });
};
var Or = (e) => {
  const t = H(), n = {
    addBlock: t.sideMenu.addBlock,
    blockDragStart: t.sideMenu.blockDragStart,
    blockDragEnd: t.sideMenu.blockDragEnd,
    freezeMenu: t.sideMenu.freezeMenu,
    unfreezeMenu: t.sideMenu.unfreezeMenu
  }, o = K(
    t.sideMenu.onUpdate.bind(t.sideMenu)
  ), { isMounted: l2, ref: a, style: c, getFloatingProps: u } = ee(
    (o == null ? void 0 : o.show) || false,
    (o == null ? void 0 : o.referencePos) || null,
    1e3,
    {
      placement: "left-start"
    }
  );
  if (!l2 || !o)
    return null;
  const { show: d, referencePos: s, ...m } = o, g = e.sideMenu || Pr2;
  return r.jsx("div", { ref: a, style: c, ...u(), children: r.jsx(g, { ...m, ...n, editor: t }) });
};
function Fr(e) {
  const t = C(), n = V(), { items: o, loadingState: l2, selectedIndex: a, onItemClick: c } = e, u = l2 === "loading-initial" || l2 === "loading" ? r.jsx(t.SuggestionMenu.Loader, { className: "bn-suggestion-menu-loader", children: n.suggestion_menu.loading }) : null, d = (0, import_react2.useMemo)(() => {
    let s;
    const m = [];
    for (let g = 0; g < o.length; g++) {
      const h = o[g];
      h.group !== s && (s = h.group, m.push(
        r.jsx(
          t.SuggestionMenu.Label,
          {
            className: "bn-suggestion-menu-label",
            children: s
          },
          s
        )
      )), m.push(
        r.jsx(
          t.SuggestionMenu.Item,
          {
            className: "bn-suggestion-menu-item",
            item: h,
            id: `bn-suggestion-menu-item-${g}`,
            isSelected: g === a,
            onClick: () => c == null ? void 0 : c(h)
          },
          h.title
        )
      );
    }
    return m;
  }, [t, o, c, a]);
  return r.jsxs(
    t.SuggestionMenu.Root,
    {
      id: "bn-suggestion-menu",
      className: "bn-suggestion-menu",
      children: [
        d,
        d.length === 0 && (e.loadingState === "loading" || e.loadingState === "loaded") && r.jsx(
          t.SuggestionMenu.EmptyItem,
          {
            className: "bn-suggestion-menu-item",
            children: n.suggestion_menu.no_items_title
          }
        ),
        u
      ]
    }
  );
}
function mn(e, t, n, o = 3) {
  const l2 = (0, import_react2.useRef)(0);
  (0, import_react2.useEffect)(() => {
    t !== void 0 && (e.length > 0 ? l2.current = t.length : t.length - l2.current > o && n());
  }, [n, o, e.length, t]);
}
function hn(e, t) {
  const [n, o] = (0, import_react2.useState)([]), [l2, a] = (0, import_react2.useState)(false), c = (0, import_react2.useRef)(), u = (0, import_react2.useRef)();
  return (0, import_react2.useEffect)(() => {
    const d = e;
    c.current = e, a(true), t(e).then((s) => {
      c.current === d && (o(s), a(false), u.current = d);
    });
  }, [e, t]), {
    items: n || [],
    // The query that was used to retrieve the last set of items may not be the
    // same as the current query as the items from the current query may not
    // have been retrieved yet. This is useful when using the returns of this
    // hook in other hooks.
    usedQuery: u.current,
    loadingState: u.current === void 0 ? "loading-initial" : l2 ? "loading" : "loaded"
  };
}
function Nr2(e, t, n, o) {
  const [l2, a] = (0, import_react2.useState)(0);
  return (0, import_react2.useEffect)(() => {
    const c = (u) => u.key === "ArrowUp" ? (u.preventDefault(), n.length && a((l2 - 1 + n.length) % n.length), true) : u.key === "ArrowDown" ? (u.preventDefault(), n.length && a((l2 + 1) % n.length), true) : u.key === "Enter" && !u.isComposing ? (u.preventDefault(), n.length && (o == null || o(n[l2])), true) : false;
    return e.domElement.addEventListener(
      "keydown",
      c,
      true
    ), () => {
      e.domElement.removeEventListener(
        "keydown",
        c,
        true
      );
    };
  }, [e.domElement, n, l2, o]), (0, import_react2.useEffect)(() => {
    a(0);
  }, [t]), {
    selectedIndex: n.length === 0 ? void 0 : l2
  };
}
function Ir2(e) {
  const n = z2().setContentEditableProps, o = H(), {
    getItems: l2,
    suggestionMenuComponent: a,
    query: c,
    clearQuery: u,
    closeMenu: d,
    onItemClick: s
  } = e, m = (0, import_react2.useCallback)(
    (T) => {
      d(), u(), s == null || s(T);
    },
    [s, d, u]
  ), { items: g, usedQuery: h, loadingState: v } = hn(
    c,
    l2
  );
  mn(g, h, d);
  const { selectedIndex: E } = Nr2(
    o,
    c,
    g,
    m
  );
  (0, import_react2.useEffect)(() => (n((T) => ({
    ...T,
    "aria-expanded": true,
    "aria-controls": "bn-suggestion-menu"
  })), () => {
    n((T) => ({
      ...T,
      "aria-expanded": false,
      "aria-controls": void 0
    }));
  }), [n]), (0, import_react2.useEffect)(() => (n((T) => ({
    ...T,
    "aria-activedescendant": E ? "bn-suggestion-menu-item-" + E : void 0
  })), () => {
    n((T) => ({
      ...T,
      "aria-activedescendant": void 0
    }));
  }), [n, E]);
  const B = a;
  return r.jsx(
    B,
    {
      items: g,
      onItemClick: m,
      loadingState: v,
      selectedIndex: E
    }
  );
}
var Dr2 = {
  heading: en,
  heading_2: tn,
  heading_3: nn,
  numbered_list: ln,
  bullet_list: an,
  check_list: rn,
  paragraph: Xe,
  table: Go,
  image: cn,
  video: qo,
  audio: sn,
  file: je,
  emoji: tr
};
function Ar2(e) {
  return Ur(e).map((t) => {
    const n = Dr2[t.key];
    return {
      ...t,
      icon: r.jsx(n, { size: 18 })
    };
  });
}
function Zr(e) {
  const t = H(), {
    triggerCharacter: n,
    suggestionMenuComponent: o,
    minQueryLength: l2,
    onItemClick: a,
    getItems: c
  } = e, u = (0, import_react2.useMemo)(() => a || ((T) => {
    T.onItemClick(t);
  }), [t, a]), d = (0, import_react2.useMemo)(() => c || (async (T) => jr(
    Ar2(t),
    T
  )), [t, c]), s = {
    closeMenu: t.suggestionMenus.closeMenu,
    clearQuery: t.suggestionMenus.clearQuery
  }, m = (0, import_react2.useCallback)(
    (T) => t.suggestionMenus.onUpdate(n, T),
    [t.suggestionMenus, n]
  ), g = K(m), { isMounted: h, ref: v, style: E, getFloatingProps: B } = ee(
    (g == null ? void 0 : g.show) || false,
    (g == null ? void 0 : g.referencePos) || null,
    2e3,
    {
      placement: "bottom-start",
      middleware: [
        offset(10),
        // Flips the menu placement to maximize the space available, and prevents
        // the menu from being cut off by the confines of the screen.
        flip({
          mainAxis: true,
          crossAxis: false
        }),
        shift(),
        size({
          apply({ availableHeight: T, elements: M }) {
            Object.assign(M.floating.style, {
              maxHeight: `${T - 10}px`
            });
          }
        })
      ],
      onOpenChange(T) {
        T || t.suggestionMenus.closeMenu();
      }
    }
  );
  return !h || !g || l2 && (g.query.startsWith(" ") || g.query.length < l2) ? null : r.jsx("div", { ref: v, style: E, ...B(), children: r.jsx(
    Ir2,
    {
      query: g.query,
      closeMenu: s.closeMenu,
      clearQuery: s.clearQuery,
      getItems: d,
      suggestionMenuComponent: o || Fr,
      onItemClick: u
    }
  ) });
}
async function Ur2(e, t) {
  return (await Dr(e, t)).map(
    ({ id: n, onItemClick: o }) => ({
      id: n,
      onItemClick: o,
      icon: n
    })
  );
}
function zr(e) {
  const t = C(), n = V(), { items: o, loadingState: l2, selectedIndex: a, onItemClick: c, columns: u } = e, d = l2 === "loading-initial" || l2 === "loading" ? r.jsx(
    t.GridSuggestionMenu.Loader,
    {
      className: "bn-grid-suggestion-menu-loader",
      columns: u,
      children: n.suggestion_menu.loading
    }
  ) : null, s = (0, import_react2.useMemo)(() => {
    const m = [];
    for (let g = 0; g < o.length; g++) {
      const h = o[g];
      m.push(
        r.jsx(
          t.GridSuggestionMenu.Item,
          {
            className: "bn-grid-suggestion-menu-item",
            item: h,
            id: `bn-grid-suggestion-menu-item-${g}`,
            isSelected: g === a,
            onClick: () => c == null ? void 0 : c(h)
          },
          h.id
        )
      );
    }
    return m;
  }, [t, o, c, a]);
  return r.jsxs(
    t.GridSuggestionMenu.Root,
    {
      id: "bn-grid-suggestion-menu",
      columns: u,
      className: "bn-grid-suggestion-menu",
      children: [
        d,
        s,
        s.length === 0 && e.loadingState === "loaded" && r.jsx(
          t.GridSuggestionMenu.EmptyItem,
          {
            className: "bn-grid-suggestion-menu-empty-item",
            columns: u,
            children: n.suggestion_menu.no_items_title
          }
        )
      ]
    }
  );
}
function Wr(e, t, n, o, l2) {
  const [a, c] = (0, import_react2.useState)(0), u = o !== void 0 && o > 1;
  return (0, import_react2.useEffect)(() => {
    const d = (s) => (s.key === "ArrowLeft" && (s.preventDefault(), n.length && c((a - 1 + n.length) % n.length)), s.key === "ArrowRight" && (s.preventDefault(), n.length && c((a + 1 + n.length) % n.length)), s.key === "ArrowUp" ? (s.preventDefault(), n.length && c(
      (a - o + n.length) % n.length
    ), true) : s.key === "ArrowDown" ? (s.preventDefault(), n.length && c((a + o) % n.length), true) : s.key === "Enter" && !s.isComposing ? (s.preventDefault(), n.length && (l2 == null || l2(n[a])), true) : false);
    return e.domElement.addEventListener(
      "keydown",
      d,
      true
    ), () => {
      e.domElement.removeEventListener(
        "keydown",
        d,
        true
      );
    };
  }, [e.domElement, n, a, l2, o, u]), (0, import_react2.useEffect)(() => {
    c(0);
  }, [t]), {
    selectedIndex: n.length === 0 ? void 0 : a
  };
}
function Gr(e) {
  const n = z2().setContentEditableProps, o = H(), {
    getItems: l2,
    gridSuggestionMenuComponent: a,
    query: c,
    clearQuery: u,
    closeMenu: d,
    onItemClick: s,
    columns: m
  } = e, g = (0, import_react2.useCallback)(
    (M) => {
      d(), u(), s == null || s(M);
    },
    [s, d, u]
  ), { items: h, usedQuery: v, loadingState: E } = hn(
    c,
    l2
  );
  mn(h, v, d);
  const { selectedIndex: B } = Wr(
    o,
    c,
    h,
    m,
    g
  );
  (0, import_react2.useEffect)(() => (n((M) => ({
    ...M,
    "aria-expanded": true,
    "aria-controls": "bn-suggestion-menu"
  })), () => {
    n((M) => ({
      ...M,
      "aria-expanded": false,
      "aria-controls": void 0
    }));
  }), [n]), (0, import_react2.useEffect)(() => (n((M) => ({
    ...M,
    "aria-activedescendant": B ? "bn-suggestion-menu-item-" + B : void 0
  })), () => {
    n((M) => ({
      ...M,
      "aria-activedescendant": void 0
    }));
  }), [n, B]);
  const T = a;
  return r.jsx(
    T,
    {
      items: h,
      onItemClick: g,
      loadingState: E,
      selectedIndex: B,
      columns: m
    }
  );
}
function $r(e) {
  const t = H(), {
    triggerCharacter: n,
    gridSuggestionMenuComponent: o,
    columns: l2,
    minQueryLength: a,
    onItemClick: c,
    getItems: u
  } = e, d = (0, import_react2.useMemo)(() => c || ((M) => {
    M.onItemClick(t);
  }), [t, c]), s = (0, import_react2.useMemo)(() => u || (async (M) => await Ur2(
    t,
    M
  )), [t, u]), m = {
    closeMenu: t.suggestionMenus.closeMenu,
    clearQuery: t.suggestionMenus.clearQuery
  }, g = (0, import_react2.useCallback)(
    (M) => t.suggestionMenus.onUpdate(n, M),
    [t.suggestionMenus, n]
  ), h = K(g), { isMounted: v, ref: E, style: B, getFloatingProps: T } = ee(
    (h == null ? void 0 : h.show) || false,
    (h == null ? void 0 : h.referencePos) || null,
    2e3,
    {
      placement: "bottom-start",
      middleware: [
        offset(10),
        // Flips the menu placement to maximize the space available, and prevents
        // the menu from being cut off by the confines of the screen.
        flip(),
        size({
          apply({ availableHeight: M, elements: O2 }) {
            Object.assign(O2.floating.style, {
              maxHeight: `${M - 10}px`
            });
          }
        })
      ],
      onOpenChange(M) {
        M || t.suggestionMenus.closeMenu();
      }
    }
  );
  return !v || !h || !(h != null && h.ignoreQueryLength) && a && (h.query.startsWith(" ") || h.query.length < a) ? null : r.jsx("div", { ref: E, style: B, ...T(), children: r.jsx(
    Gr,
    {
      query: h.query,
      closeMenu: m.closeMenu,
      clearQuery: m.clearQuery,
      getItems: s,
      columns: l2,
      gridSuggestionMenuComponent: o || zr,
      onItemClick: d
    }
  ) });
}
var qr = (e) => {
  const t = C(), n = V(), o = H();
  return r.jsx(
    t.Generic.Menu.Item,
    {
      onClick: () => {
        const l2 = e.block.content.rows[e.index].cells.map(
          () => []
        ), a = [...e.block.content.rows];
        a.splice(e.index + (e.side === "below" ? 1 : 0), 0, {
          cells: l2
        }), o.updateBlock(e.block, {
          type: "table",
          content: {
            type: "tableContent",
            rows: a
          }
        });
      },
      children: n.table_handle[`add_${e.side}_menuitem`]
    }
  );
};
var Yr = (e) => {
  const t = C(), n = V(), o = H();
  return r.jsx(
    t.Generic.Menu.Item,
    {
      onClick: () => {
        const l2 = {
          type: "tableContent",
          rows: e.block.content.rows.map((a) => {
            const c = [...a.cells];
            return c.splice(e.index + (e.side === "right" ? 1 : 0), 0, []), { cells: c };
          })
        };
        o.updateBlock(e.block, {
          type: "table",
          content: l2
        });
      },
      children: n.table_handle[`add_${e.side}_menuitem`]
    }
  );
};
var Bt = (e) => e.orientation === "row" ? r.jsx(qr, { ...e, side: e.side }) : r.jsx(Yr, { ...e, side: e.side });
var Kr = (e) => {
  const t = C(), n = V(), o = H();
  return r.jsx(
    t.Generic.Menu.Item,
    {
      onClick: () => {
        const l2 = {
          type: "tableContent",
          rows: e.block.content.rows.filter(
            (a, c) => c !== e.index
          )
        };
        o.updateBlock(e.block, {
          type: "table",
          content: l2
        });
      },
      children: n.table_handle.delete_row_menuitem
    }
  );
};
var Xr = (e) => {
  const t = C(), n = V(), o = H();
  return r.jsx(
    t.Generic.Menu.Item,
    {
      onClick: () => {
        const l2 = {
          type: "tableContent",
          rows: e.block.content.rows.map((a) => ({
            cells: a.cells.filter((c, u) => u !== e.index)
          }))
        };
        o.updateBlock(e.block, {
          type: "table",
          content: l2
        });
      },
      children: n.table_handle.delete_column_menuitem
    }
  );
};
var Jr = (e) => e.orientation === "row" ? r.jsx(Kr, { ...e }) : r.jsx(Xr, { ...e });
var Qr = (e) => {
  const t = C();
  return r.jsx(t.Generic.Menu.Dropdown, { className: "bn-table-handle-menu", children: e.children || r.jsxs(r.Fragment, { children: [
    r.jsx(
      Jr,
      {
        orientation: e.orientation,
        block: e.block,
        index: e.index
      }
    ),
    r.jsx(
      Bt,
      {
        orientation: e.orientation,
        block: e.block,
        index: e.index,
        side: e.orientation === "row" ? "above" : "left"
      }
    ),
    r.jsx(
      Bt,
      {
        orientation: e.orientation,
        block: e.block,
        index: e.index,
        side: e.orientation === "row" ? "below" : "right"
      }
    )
  ] }) });
};
var ei = (e) => {
  const t = C(), [n, o] = (0, import_react2.useState)(false), l2 = e.tableHandleMenu || Qr;
  return r.jsxs(
    t.Generic.Menu.Root,
    {
      onOpenChange: (a) => {
        a ? (e.freezeHandles(), e.hideOtherSide()) : (e.unfreezeHandles(), e.showOtherSide(), e.editor.focus());
      },
      position: "right",
      children: [
        r.jsx(t.Generic.Menu.Trigger, { children: r.jsx(
          t.TableHandle.Root,
          {
            className: z(
              "bn-table-handle",
              n ? "bn-table-handle-dragging" : ""
            ),
            draggable: true,
            onDragStart: (a) => {
              o(true), e.dragStart(a);
            },
            onDragEnd: () => {
              e.dragEnd(), o(false);
            },
            style: e.orientation === "column" ? { transform: "rotate(0.25turn)" } : void 0,
            children: e.children || r.jsx(gn, { size: 24, "data-test": "tableHandle" })
          }
        ) }),
        r.jsx(
          l2,
          {
            orientation: e.orientation,
            block: e.block,
            index: e.index
          }
        )
      ]
    }
  );
};
function ti(e, t, n) {
  return n && n.draggedCellOrientation === "row" ? new DOMRect(
    t.x,
    n.mousePos,
    t.width,
    0
  ) : new DOMRect(
    t.x,
    e.y,
    t.width,
    e.height
  );
}
function ni(e, t, n) {
  return n && n.draggedCellOrientation === "col" ? new DOMRect(
    n.mousePos,
    t.y,
    0,
    t.height
  ) : new DOMRect(
    e.x,
    t.y,
    e.width,
    t.height
  );
}
function Pt(e, t, n, o, l2) {
  const { refs: a, update: c, context: u, floatingStyles: d } = useFloating({
    open: t,
    placement: e === "row" ? "left" : "top",
    middleware: [offset(e === "row" ? -10 : -12)]
  }), { isMounted: s, styles: m } = useTransitionStyles(u);
  return (0, import_react2.useEffect)(() => {
    c();
  }, [n, o, c]), (0, import_react2.useEffect)(() => {
    n === null || o === null || a.setReference({
      getBoundingClientRect: () => (e === "row" ? ti : ni)(n, o, l2)
    });
  }, [l2, e, n, o, a]), (0, import_react2.useMemo)(
    () => ({
      isMounted: s,
      ref: a.setFloating,
      style: {
        display: "flex",
        ...m,
        ...d,
        zIndex: 1e4
      }
    }),
    [d, s, a.setFloating, m]
  );
}
function oi(e, t, n, o) {
  const l2 = Pt(
    "row",
    e,
    t,
    n,
    o
  ), a = Pt(
    "col",
    e,
    t,
    n,
    o
  );
  return (0, import_react2.useMemo)(
    () => ({
      rowHandle: l2,
      colHandle: a
    }),
    [a, l2]
  );
}
var ri = (e) => {
  var h, v;
  const t = H();
  if (!t.tableHandles)
    throw new Error(
      "TableHandlesController can only be used when BlockNote editor schema contains table block"
    );
  const n = {
    rowDragStart: t.tableHandles.rowDragStart,
    colDragStart: t.tableHandles.colDragStart,
    dragEnd: t.tableHandles.dragEnd,
    freezeHandles: t.tableHandles.freezeHandles,
    unfreezeHandles: t.tableHandles.unfreezeHandles
  }, o = K(
    t.tableHandles.onUpdate.bind(t.tableHandles)
  ), l2 = (0, import_react2.useMemo)(() => {
    var E, B;
    return o != null && o.draggingState ? {
      draggedCellOrientation: (E = o == null ? void 0 : o.draggingState) == null ? void 0 : E.draggedCellOrientation,
      mousePos: (B = o == null ? void 0 : o.draggingState) == null ? void 0 : B.mousePos
    } : void 0;
  }, [
    o == null ? void 0 : o.draggingState,
    (h = o == null ? void 0 : o.draggingState) == null ? void 0 : h.draggedCellOrientation,
    (v = o == null ? void 0 : o.draggingState) == null ? void 0 : v.mousePos
  ]), { rowHandle: a, colHandle: c } = oi(
    (o == null ? void 0 : o.show) || false,
    (o == null ? void 0 : o.referencePosCell) || null,
    (o == null ? void 0 : o.referencePosTable) || null,
    l2
  ), [u, d] = (0, import_react2.useState)(false), [s, m] = (0, import_react2.useState)(false);
  if (!a.isMounted || !c.isMounted || !o)
    return null;
  const g = e.tableHandle || ei;
  return r.jsxs(r.Fragment, { children: [
    !u && r.jsx("div", { ref: a.ref, style: a.style, children: r.jsx(
      g,
      {
        editor: t,
        orientation: "row",
        showOtherSide: () => m(false),
        hideOtherSide: () => m(true),
        index: o.rowIndex,
        block: o.block,
        dragStart: n.rowDragStart,
        dragEnd: n.dragEnd,
        freezeHandles: n.freezeHandles,
        unfreezeHandles: n.unfreezeHandles
      }
    ) }),
    !s && r.jsx("div", { ref: c.ref, style: c.style, children: r.jsx(
      g,
      {
        editor: t,
        orientation: "column",
        showOtherSide: () => d(false),
        hideOtherSide: () => d(true),
        index: o.colIndex,
        block: o.block,
        dragStart: n.colDragStart,
        dragEnd: n.dragEnd,
        freezeHandles: n.freezeHandles,
        unfreezeHandles: n.unfreezeHandles
      }
    ) })
  ] });
};
function ii(e) {
  const t = H();
  if (!t)
    throw new Error(
      "BlockNoteDefaultUI must be used within a BlockNoteContext.Provider"
    );
  return r.jsxs(r.Fragment, { children: [
    e.formattingToolbar !== false && r.jsx(yr, {}),
    e.linkToolbar !== false && r.jsx(Mr, {}),
    e.slashMenu !== false && r.jsx(Zr, { triggerCharacter: "/" }),
    e.emojiPicker !== false && r.jsx(
      $r,
      {
        triggerCharacter: ":",
        columns: 10,
        minQueryLength: 2
      }
    ),
    e.sideMenu !== false && r.jsx(Or, {}),
    t.filePanel && e.filePanel !== false && r.jsx(_r, {}),
    t.tableHandles && e.tableHandles !== false && r.jsx(ri, {})
  ] });
}
var li = () => {
  const e = (0, import_react2.useMemo)(
    () => {
      var c;
      return (c = window.matchMedia) == null ? void 0 : c.call(window, "(prefers-color-scheme: dark)");
    },
    []
  ), t = (0, import_react2.useMemo)(
    () => {
      var c;
      return (c = window.matchMedia) == null ? void 0 : c.call(window, "(prefers-color-scheme: light)");
    },
    []
  ), n = e == null ? void 0 : e.matches, o = t == null ? void 0 : t.matches, [l2, a] = (0, import_react2.useState)(n ? "dark" : o ? "light" : "no-preference");
  return (0, import_react2.useEffect)(() => {
    a(n ? "dark" : o ? "light" : "no-preference");
  }, [n, o]), (0, import_react2.useEffect)(() => {
    if (typeof (e == null ? void 0 : e.addEventListener) == "function") {
      const c = ({ matches: d }) => d && a("dark"), u = ({ matches: d }) => d && a("light");
      return e == null || e.addEventListener("change", c), t == null || t.addEventListener("change", u), () => {
        e == null || e.removeEventListener("change", c), t == null || t.removeEventListener("change", u);
      };
    } else {
      const c = () => a(
        e.matches ? "dark" : t.matches ? "light" : "no-preference"
      );
      return e == null || e.addEventListener("change", c), t == null || t.addEventListener("change", c), () => {
        e == null || e.removeEventListener("change", c), t == null || t.removeEventListener("change", c);
      };
    }
  }, [e, t]), typeof window.matchMedia != "function", l2;
};
var ai = ({
  renderers: e
}) => r.jsx(r.Fragment, { children: Object.entries(e).map(([t, n]) => (0, import_react_dom2.createPortal)(n.reactElement, n.element, t)) });
function ci(e) {
  const [t, n] = (0, import_react2.useState)({});
  return (0, import_react2.useEffect)(() => (e.editor._tiptapEditor.contentComponent = {
    /**
     * Used by TipTap
     */
    setRenderer(o, l2) {
      n((a) => ({ ...a, [o]: l2 }));
    },
    /**
     * Used by TipTap
     */
    removeRenderer(o) {
      n((l2) => {
        const a = { ...l2 };
        return delete a[o], a;
      });
    }
  }, queueMicrotask(() => {
    e.editor._tiptapEditor.createNodeViews();
  }), () => {
    e.editor._tiptapEditor.contentComponent = null;
  }), [e.editor._tiptapEditor]), r.jsxs(r.Fragment, { children: [
    r.jsx(ai, { renderers: t }),
    e.children
  ] });
}
var si = (0, import_react2.forwardRef)((e, t) => {
  const [n, o] = (0, import_react2.useState)();
  return (0, import_react2.useImperativeHandle)(
    t,
    () => (l2, a) => {
      (0, import_react_dom2.flushSync)(() => {
        o({ node: l2, container: a });
      }), o(void 0);
    },
    []
  ), r.jsx(r.Fragment, { children: n && (0, import_react_dom2.createPortal)(n.node, n.container) });
});
var Ot = () => {
};
function ui(e, t) {
  const {
    editor: n,
    className: o,
    theme: l2,
    children: a,
    editable: c,
    onSelectionChange: u,
    onChange: d,
    formattingToolbar: s,
    linkToolbar: m,
    slashMenu: g,
    emojiPicker: h,
    sideMenu: v,
    filePanel: E,
    tableHandles: B,
    ...T
  } = e, [M, O2] = (0, import_react2.useState)(), G = z2(), _e = li(), Ve2 = (G == null ? void 0 : G.colorSchemePreference) || _e, ue = l2 || (Ve2 === "dark" ? "dark" : "light");
  Ye(d || Ot, n), Ke(u || Ot, n), (0, import_react2.useEffect)(() => {
    n.isEditable = c !== false;
  }, [c, n]);
  const Ee = (0, import_react2.useMemo)(() => r.jsxs(r.Fragment, { children: [
    a,
    r.jsx(
      ii,
      {
        formattingToolbar: s,
        linkToolbar: m,
        slashMenu: g,
        emojiPicker: h,
        sideMenu: v,
        filePanel: E,
        tableHandles: B
      }
    )
  ] }), [
    a,
    s,
    m,
    g,
    h,
    v,
    E,
    B
  ]), Te = (0, import_react2.useMemo)(() => ({
    ...G,
    editor: n,
    setContentEditableProps: O2
  }), [G, n]), de = (0, import_react2.useCallback)(
    (Le) => {
      n.elementRenderer = Le;
    },
    [n]
  );
  return r.jsxs(Xt.Provider, { value: Te, children: [
    r.jsx(si, { ref: de }),
    !n.headless && r.jsx(ci, { editor: n, children: r.jsxs(
      "div",
      {
        className: z(
          "bn-container",
          ue || "",
          o || ""
        ),
        "data-color-scheme": ue,
        ...T,
        ref: t,
        children: [
          r.jsx(
            "div",
            {
              "aria-autocomplete": "list",
              "aria-haspopup": "listbox",
              ref: n.mount,
              ...M
            }
          ),
          Ee
        ]
      }
    ) })
  ] });
}
var Si = import_react2.default.forwardRef(ui);
var $e;
var pe = import_react_dom2.default;
if (false)
  $e = pe.createRoot, pe.hydrateRoot;
else {
  Ft2 = pe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  $e = function(e, t) {
    Ft2.usingClientEntryPoint = true;
    try {
      return pe.createRoot(e, t);
    } finally {
      Ft2.usingClientEntryPoint = false;
    }
  };
}
var Ft2;
function ke(e, t) {
  let n;
  const o = document.createElement("div");
  let l2;
  if (t != null && t.elementRenderer ? t.elementRenderer(
    e((d) => n = d || void 0),
    o
  ) : (l2 = $e(o), (0, import_react_dom2.flushSync)(() => {
    l2.render(e((d) => n = d || void 0));
  })), !o.childElementCount)
    return console.warn("ReactInlineContentSpec: renderHTML() failed"), {
      dom: document.createElement("span")
    };
  n == null || n.setAttribute("data-tmp-find", "true");
  const a = o.cloneNode(true), c = a.firstElementChild, u = a.querySelector(
    "[data-tmp-find]"
  );
  return u == null || u.removeAttribute("data-tmp-find"), l2 == null || l2.unmount(), {
    dom: c,
    contentDOM: u || void 0
  };
}
function Ue(e) {
  var t;
  return (
    // Creates `blockContent` element
    r.jsx(
      NodeViewWrapper,
      {
        ...Object.fromEntries(
          Object.entries(e.domAttributes || {}).filter(
            ([n]) => n !== "class"
          )
        ),
        className: z(
          "bn-block-content",
          ((t = e.domAttributes) == null ? void 0 : t.class) || ""
        ),
        "data-content-type": e.blockType,
        ...Object.fromEntries(
          Object.entries(e.blockProps).filter(
            ([n, o]) => !rt.includes(n) && o !== e.propSchema[n].default
          ).map(([n, o]) => [le(n), o])
        ),
        "data-file-block": e.isFileBlock === true || void 0,
        children: e.children
      }
    )
  );
}
function we(e, t) {
  const n = O({
    name: e.type,
    content: e.content === "inline" ? "inline*" : "",
    group: "blockContent",
    selectable: true,
    addAttributes() {
      return at(e.propSchema);
    },
    parseHTML() {
      return Ii(e, t.parse);
    },
    renderHTML() {
      const o = document.createElement("div");
      return o.setAttribute("data-tmp-placeholder", "true"), {
        dom: o
      };
    },
    addNodeView() {
      return (o) => ReactNodeViewRenderer(
        (l2) => {
          var m;
          const a = this.options.editor, c = Li(
            l2.getPos,
            a,
            this.editor,
            e.type
          ), u = ((m = this.options.domAttributes) == null ? void 0 : m.blockContent) || {}, d = NodeViewContent({}).ref, s = t.render;
          return r.jsx(
            Ue,
            {
              blockType: c.type,
              blockProps: c.props,
              propSchema: e.propSchema,
              isFileBlock: e.isFileBlock,
              domAttributes: u,
              children: r.jsx(
                s,
                {
                  block: c,
                  editor: a,
                  contentRef: d
                }
              )
            }
          );
        },
        {
          className: "bn-react-node-view-renderer"
        }
      )(o);
    }
  });
  return st(e, {
    node: n,
    toInternalHTML: (o, l2) => {
      var d, s;
      const a = ((d = n.options.domAttributes) == null ? void 0 : d.blockContent) || {}, c = t.render, u = ke(
        (m) => r.jsx(
          Ue,
          {
            blockType: o.type,
            blockProps: o.props,
            propSchema: e.propSchema,
            domAttributes: a,
            children: r.jsx(
              c,
              {
                block: o,
                editor: l2,
                contentRef: m
              }
            )
          }
        ),
        l2
      );
      return (s = u.contentDOM) == null || s.setAttribute("data-editable", ""), u;
    },
    toExternalHTML: (o, l2) => {
      var d, s;
      const a = ((d = n.options.domAttributes) == null ? void 0 : d.blockContent) || {}, c = t.toExternalHTML || t.render, u = ke((m) => r.jsx(
        Ue,
        {
          blockType: o.type,
          blockProps: o.props,
          propSchema: e.propSchema,
          domAttributes: a,
          children: r.jsx(
            c,
            {
              block: o,
              editor: l2,
              contentRef: m
            }
          )
        }
      ), l2);
      return (s = u.contentDOM) == null || s.setAttribute("data-editable", ""), u;
    }
  });
}
var He = (e) => r.jsxs(
  "div",
  {
    className: "bn-file-default-preview",
    contentEditable: false,
    draggable: false,
    children: [
      r.jsx("div", { className: "bn-file-default-preview-icon", children: r.jsx(je, { size: 24 }) }),
      r.jsx("p", { className: "bn-file-default-preview-name", children: e.block.props.name })
    ]
  }
);
var Y = (e) => r.jsxs("div", { className: "bn-file-and-caption-wrapper", children: [
  e.children,
  e.block.props.caption && r.jsx("p", { className: "bn-file-caption", children: e.block.props.caption })
] });
var Se = (e) => {
  const t = (0, import_react2.useCallback)(
    (o) => {
      o.preventDefault();
    },
    []
  ), n = (0, import_react2.useCallback)(() => {
    e.editor.dispatch(
      e.editor._tiptapEditor.state.tr.setMeta(
        e.editor.filePanel.plugin,
        {
          block: e.block
        }
      )
    );
  }, [e.block, e.editor]);
  return r.jsxs(
    "div",
    {
      className: "bn-add-file-button",
      onMouseDown: t,
      onClick: n,
      children: [
        r.jsx("div", { className: "bn-add-file-button-icon", children: e.buttonIcon || r.jsx(je, { size: 24 }) }),
        r.jsx("div", { className: "bn-add-file-button-text", children: e.buttonText })
      ]
    }
  );
};
var Me = (e) => r.jsxs("div", { children: [
  e.children,
  r.jsx("p", { children: e.caption })
] });
var Je = (e) => r.jsxs("figure", { children: [
  e.children,
  r.jsx("figcaption", { children: e.caption })
] });
var bn = (e) => {
  const [t, n] = (0, import_react2.useState)(false), [o, l2] = (0, import_react2.useState)(void 0);
  (0, import_react2.useEffect)(() => {
    const s = (g) => {
      let h;
      e.block.props.textAlignment === "center" ? o.handleUsed === "left" ? h = o.initialWidth + (o.initialClientX - g.clientX) * 2 : h = o.initialWidth + (g.clientX - o.initialClientX) * 2 : o.handleUsed === "left" ? h = o.initialWidth + o.initialClientX - g.clientX : h = o.initialWidth + g.clientX - o.initialClientX;
      const v = 64;
      h < v ? e.setWidth(v) : h > e.editor.domElement.firstElementChild.clientWidth ? e.setWidth(e.editor.domElement.firstElementChild.clientWidth) : e.setWidth(h);
    }, m = () => {
      l2(void 0), e.editor.updateBlock(e.block, {
        props: {
          previewWidth: e.width
        }
      });
    };
    return o && (window.addEventListener("mousemove", s), window.addEventListener("mouseup", m)), () => {
      window.removeEventListener("mousemove", s), window.removeEventListener("mouseup", m);
    };
  }, [e, o]);
  const a = (0, import_react2.useCallback)(() => {
    e.editor.isEditable && n(true);
  }, [e.editor.isEditable]), c = (0, import_react2.useCallback)(() => {
    n(false);
  }, []), u = (0, import_react2.useCallback)(
    (s) => {
      s.preventDefault(), l2({
        handleUsed: "left",
        initialWidth: e.width,
        initialClientX: s.clientX
      });
    },
    [e.width]
  ), d = (0, import_react2.useCallback)(
    (s) => {
      s.preventDefault(), l2({
        handleUsed: "right",
        initialWidth: e.width,
        initialClientX: s.clientX
      });
    },
    [e.width]
  );
  return r.jsxs(
    "div",
    {
      className: "bn-visual-media-wrapper",
      onMouseEnter: a,
      onMouseLeave: c,
      children: [
        e.children,
        (t || o) && r.jsxs(r.Fragment, { children: [
          r.jsx(
            "div",
            {
              className: "bn-visual-media-resize-handle",
              style: { left: "4px" },
              onMouseDown: u
            }
          ),
          r.jsx(
            "div",
            {
              className: "bn-visual-media-resize-handle",
              style: { right: "4px" },
              onMouseDown: d
            }
          )
        ] })
      ]
    }
  );
};
function Qe(e) {
  const t = H(), [n, o] = (0, import_react2.useState)("loading"), [l2, a] = (0, import_react2.useState)();
  if ((0, import_react2.useEffect)(() => {
    let c = true;
    return (async () => {
      let u = "";
      o("loading");
      try {
        u = await t.resolveFileUrl(e);
      } catch {
        o("error");
        return;
      }
      c && (o("loaded"), a(u));
    })(), () => {
      c = false;
    };
  }, [t, e]), n !== "loaded")
    return {
      loadingState: n
    };
  if (!l2)
    throw new Error("Finished fetching file but did not get download URL.");
  return {
    loadingState: n,
    downloadUrl: l2
  };
}
var di = (e) => {
  const t = Qe(e.block.props.url);
  return t.loadingState === "loading" ? null : r.jsx(
    "audio",
    {
      className: "bn-audio",
      src: t.downloadUrl,
      controls: true,
      contentEditable: false,
      draggable: false
    }
  );
};
var fi = (e) => {
  if (!e.block.props.url)
    return r.jsx("p", { children: "Add audio" });
  const t = e.block.props.showPreview ? r.jsx("audio", { src: e.block.props.url }) : r.jsx("a", { href: e.block.props.url, children: e.block.props.name || e.block.props.url });
  return e.block.props.caption ? e.block.props.showPreview ? r.jsx(Je, { caption: e.block.props.caption, children: t }) : r.jsx(Me, { caption: e.block.props.caption, children: t }) : t;
};
var Mi = we(Vi, {
  render: (e) => r.jsx("div", { className: "bn-file-block-content-wrapper", children: e.block.props.url === "" ? r.jsx(
    Se,
    {
      ...e,
      editor: e.editor,
      buttonText: e.editor.dictionary.file_blocks.audio.add_button_text,
      buttonIcon: r.jsx(sn, { size: 24 })
    }
  ) : e.block.props.showPreview ? r.jsx(Y, { block: e.block, editor: e.editor, children: r.jsx(di, { block: e.block, editor: e.editor }) }) : r.jsx(Y, { block: e.block, editor: e.editor, children: r.jsx(
    He,
    {
      block: e.block,
      editor: e.editor
    }
  ) }) }),
  parse: Fi,
  toExternalHTML: (e) => r.jsx(fi, { ...e })
});
var gi = (e) => {
  if (!e.block.props.url)
    return r.jsx("p", { children: "Add file" });
  const t = r.jsx("a", { href: e.block.props.url, children: e.block.props.name || e.block.props.url });
  return e.block.props.caption ? r.jsx(Me, { caption: e.block.props.caption, children: t }) : t;
};
var _i = we($i, {
  render: (e) => r.jsx("div", { className: "bn-file-block-content-wrapper", children: e.block.props.url === "" ? r.jsx(
    Se,
    {
      block: e.block,
      editor: e.editor,
      buttonIcon: r.jsx(je, { size: 24 }),
      buttonText: e.editor.dictionary.file_blocks.file.add_button_text
    }
  ) : r.jsx(Y, { block: e.block, editor: e.editor, children: r.jsx(
    He,
    {
      block: e.block,
      editor: e.editor
    }
  ) }) }),
  parse: Xi,
  toExternalHTML: (e) => r.jsx(gi, { ...e })
});
var mi = (e) => {
  const [t, n] = (0, import_react2.useState)(
    Math.min(
      e.block.props.previewWidth,
      e.editor.domElement.firstElementChild.clientWidth
    )
  ), o = Qe(e.block.props.url);
  return o.loadingState === "loading" ? null : r.jsx(bn, { ...e, width: t, setWidth: n, children: r.jsx(
    "img",
    {
      className: "bn-visual-media",
      src: o.downloadUrl,
      alt: e.block.props.caption || "BlockNote image",
      contentEditable: false,
      draggable: false,
      width: t
    }
  ) });
};
var hi = (e) => {
  if (!e.block.props.url)
    return r.jsx("p", { children: "Add image" });
  const t = e.block.props.showPreview ? r.jsx(
    "img",
    {
      src: e.block.props.url,
      alt: e.block.props.name || e.block.props.caption || "BlockNote image",
      width: e.block.props.previewWidth
    }
  ) : r.jsx("a", { href: e.block.props.url, children: e.block.props.name || e.block.props.url });
  return e.block.props.caption ? e.block.props.showPreview ? r.jsx(Je, { caption: e.block.props.caption, children: t }) : r.jsx(Me, { caption: e.block.props.caption, children: t }) : t;
};
var Vi2 = we(Qi, {
  render: (e) => r.jsx("div", { className: "bn-file-block-content-wrapper", children: e.block.props.url === "" ? r.jsx(
    Se,
    {
      ...e,
      editor: e.editor,
      buttonText: e.editor.dictionary.file_blocks.image.add_button_text,
      buttonIcon: r.jsx(cn, { size: 24 })
    }
  ) : e.block.props.showPreview ? r.jsx(Y, { block: e.block, editor: e.editor, children: r.jsx(mi, { block: e.block, editor: e.editor }) }) : r.jsx(Y, { block: e.block, editor: e.editor, children: r.jsx(
    He,
    {
      block: e.block,
      editor: e.editor
    }
  ) }) }),
  parse: to,
  toExternalHTML: (e) => r.jsx(hi, { ...e })
});
var bi = (e) => {
  const [t, n] = (0, import_react2.useState)(
    Math.min(
      e.block.props.previewWidth,
      e.editor.domElement.firstElementChild.clientWidth
    )
  ), o = Qe(e.block.props.url);
  return o.loadingState === "loading" ? null : r.jsx(bn, { ...e, width: t, setWidth: n, children: r.jsx(
    "video",
    {
      className: "bn-visual-media",
      src: o.downloadUrl,
      controls: true,
      contentEditable: false,
      draggable: false,
      width: t
    }
  ) });
};
var pi = (e) => {
  if (!e.block.props.url)
    return r.jsx("p", { children: "Add video" });
  const t = e.block.props.showPreview ? r.jsx("video", { src: e.block.props.url }) : r.jsx("a", { href: e.block.props.url, children: e.block.props.name || e.block.props.url });
  return e.block.props.caption ? e.block.props.showPreview ? r.jsx(Je, { caption: e.block.props.caption, children: t }) : r.jsx(Me, { caption: e.block.props.caption, children: t }) : t;
};
var Ei = we(ro, {
  render: (e) => r.jsx("div", { className: "bn-file-block-content-wrapper", children: e.block.props.url === "" ? r.jsx(
    Se,
    {
      ...e,
      editor: e.editor,
      buttonText: e.editor.dictionary.file_blocks.video.add_button_text,
      buttonIcon: r.jsx(Xo, { size: 24 })
    }
  ) : e.block.props.showPreview ? r.jsx(Y, { block: e.block, editor: e.editor, children: r.jsx(bi, { block: e.block, editor: e.editor }) }) : r.jsx(Y, { block: e.block, editor: e.editor, children: r.jsx(
    He,
    {
      block: e.block,
      editor: e.editor
    }
  ) }) }),
  parse: so,
  toExternalHTML: (e) => r.jsx(pi, { ...e })
});
function Oi(e, t) {
  const n = e.getBoundingClientRect(), o = t.getBoundingClientRect(), l2 = n.top < o.top, a = n.bottom > o.bottom;
  return l2 && a ? "both" : l2 ? "top" : a ? "bottom" : "none";
}

// node_modules/@blocknote/mantine/dist/blocknote-mantine.js
var be2 = { exports: {} };
var Y2 = {};
var Ve;
function lt() {
  return Ve || (Ve = 1, function() {
    var r2 = import_react5.default, n = Symbol.for("react.element"), t = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), u = Symbol.for("react.profiler"), f = Symbol.for("react.provider"), c = Symbol.for("react.context"), d = Symbol.for("react.forward_ref"), b = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), w2 = Symbol.for("react.memo"), T = Symbol.for("react.lazy"), G = Symbol.for("react.offscreen"), ge = Symbol.iterator, ir2 = "@@iterator";
    function sr2(e) {
      if (e === null || typeof e != "object")
        return null;
      var a = ge && e[ge] || e[ir2];
      return typeof a == "function" ? a : null;
    }
    var L = r2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function k(e) {
      {
        for (var a = arguments.length, s = new Array(a > 1 ? a - 1 : 0), v = 1; v < a; v++)
          s[v - 1] = arguments[v];
        lr2("error", e, s);
      }
    }
    function lr2(e, a, s) {
      {
        var v = L.ReactDebugCurrentFrame, x2 = v.getStackAddendum();
        x2 !== "" && (a += "%s", s = s.concat([x2]));
        var j = s.map(function(g) {
          return String(g);
        });
        j.unshift("Warning: " + a), Function.prototype.apply.call(console[e], console, j);
      }
    }
    var ur2 = false, cr2 = false, dr2 = false, fr2 = false, vr2 = false, pe2;
    pe2 = Symbol.for("react.module.reference");
    function br2(e) {
      return !!(typeof e == "string" || typeof e == "function" || e === o || e === u || vr2 || e === i || e === b || e === h || fr2 || e === G || ur2 || cr2 || dr2 || typeof e == "object" && e !== null && (e.$$typeof === T || e.$$typeof === w2 || e.$$typeof === f || e.$$typeof === c || e.$$typeof === d || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      e.$$typeof === pe2 || e.getModuleId !== void 0));
    }
    function mr2(e, a, s) {
      var v = e.displayName;
      if (v)
        return v;
      var x2 = a.displayName || a.name || "";
      return x2 !== "" ? s + "(" + x2 + ")" : s;
    }
    function he(e) {
      return e.displayName || "Context";
    }
    function N(e) {
      if (e == null)
        return null;
      if (typeof e.tag == "number" && k("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof e == "function")
        return e.displayName || e.name || null;
      if (typeof e == "string")
        return e;
      switch (e) {
        case o:
          return "Fragment";
        case t:
          return "Portal";
        case u:
          return "Profiler";
        case i:
          return "StrictMode";
        case b:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case c:
            var a = e;
            return he(a) + ".Consumer";
          case f:
            var s = e;
            return he(s._context) + ".Provider";
          case d:
            return mr2(e, e.render, "ForwardRef");
          case w2:
            var v = e.displayName || null;
            return v !== null ? v : N(e.type) || "Memo";
          case T: {
            var x2 = e, j = x2._payload, g = x2._init;
            try {
              return N(g(j));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var M = Object.assign, z3 = 0, xe2, ye, je2, Re, Ee, Se2, we2;
    function Te() {
    }
    Te.__reactDisabledLog = true;
    function gr2() {
      {
        if (z3 === 0) {
          xe2 = console.log, ye = console.info, je2 = console.warn, Re = console.error, Ee = console.group, Se2 = console.groupCollapsed, we2 = console.groupEnd;
          var e = {
            configurable: true,
            enumerable: true,
            value: Te,
            writable: true
          };
          Object.defineProperties(console, {
            info: e,
            log: e,
            warn: e,
            error: e,
            group: e,
            groupCollapsed: e,
            groupEnd: e
          });
        }
        z3++;
      }
    }
    function pr2() {
      {
        if (z3--, z3 === 0) {
          var e = {
            configurable: true,
            enumerable: true,
            writable: true
          };
          Object.defineProperties(console, {
            log: M({}, e, {
              value: xe2
            }),
            info: M({}, e, {
              value: ye
            }),
            warn: M({}, e, {
              value: je2
            }),
            error: M({}, e, {
              value: Re
            }),
            group: M({}, e, {
              value: Ee
            }),
            groupCollapsed: M({}, e, {
              value: Se2
            }),
            groupEnd: M({}, e, {
              value: we2
            })
          });
        }
        z3 < 0 && k("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ne = L.ReactCurrentDispatcher, oe;
    function K2(e, a, s) {
      {
        if (oe === void 0)
          try {
            throw Error();
          } catch (x2) {
            var v = x2.stack.trim().match(/\n( *(at )?)/);
            oe = v && v[1] || "";
          }
        return `
` + oe + e;
      }
    }
    var ae = false, q;
    {
      var hr2 = typeof WeakMap == "function" ? WeakMap : Map;
      q = new hr2();
    }
    function ke2(e, a) {
      if (!e || ae)
        return "";
      {
        var s = q.get(e);
        if (s !== void 0)
          return s;
      }
      var v;
      ae = true;
      var x2 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var j;
      j = ne.current, ne.current = null, gr2();
      try {
        if (a) {
          var g = function() {
            throw Error();
          };
          if (Object.defineProperty(g.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(g, []);
            } catch (_) {
              v = _;
            }
            Reflect.construct(e, [], g);
          } else {
            try {
              g.call();
            } catch (_) {
              v = _;
            }
            e.call(g.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (_) {
            v = _;
          }
          e();
        }
      } catch (_) {
        if (_ && v && typeof _.stack == "string") {
          for (var m = _.stack.split(`
`), P = v.stack.split(`
`), E = m.length - 1, S2 = P.length - 1; E >= 1 && S2 >= 0 && m[E] !== P[S2]; )
            S2--;
          for (; E >= 1 && S2 >= 0; E--, S2--)
            if (m[E] !== P[S2]) {
              if (E !== 1 || S2 !== 1)
                do
                  if (E--, S2--, S2 < 0 || m[E] !== P[S2]) {
                    var C2 = `
` + m[E].replace(" at new ", " at ");
                    return e.displayName && C2.includes("<anonymous>") && (C2 = C2.replace("<anonymous>", e.displayName)), typeof e == "function" && q.set(e, C2), C2;
                  }
                while (E >= 1 && S2 >= 0);
              break;
            }
        }
      } finally {
        ae = false, ne.current = j, pr2(), Error.prepareStackTrace = x2;
      }
      var $ = e ? e.displayName || e.name : "", I = $ ? K2($) : "";
      return typeof e == "function" && q.set(e, I), I;
    }
    function xr2(e, a, s) {
      return ke2(e, false);
    }
    function yr2(e) {
      var a = e.prototype;
      return !!(a && a.isReactComponent);
    }
    function H2(e, a, s) {
      if (e == null)
        return "";
      if (typeof e == "function")
        return ke2(e, yr2(e));
      if (typeof e == "string")
        return K2(e);
      switch (e) {
        case b:
          return K2("Suspense");
        case h:
          return K2("SuspenseList");
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case d:
            return xr2(e.render);
          case w2:
            return H2(e.type, a, s);
          case T: {
            var v = e, x2 = v._payload, j = v._init;
            try {
              return H2(j(x2), a, s);
            } catch {
            }
          }
        }
      return "";
    }
    var W2 = Object.prototype.hasOwnProperty, Pe = {}, _e = L.ReactDebugCurrentFrame;
    function J(e) {
      if (e) {
        var a = e._owner, s = H2(e.type, e._source, a ? a.type : null);
        _e.setExtraStackFrame(s);
      } else
        _e.setExtraStackFrame(null);
    }
    function jr3(e, a, s, v, x2) {
      {
        var j = Function.call.bind(W2);
        for (var g in e)
          if (j(e, g)) {
            var m = void 0;
            try {
              if (typeof e[g] != "function") {
                var P = Error((v || "React class") + ": " + s + " type `" + g + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e[g] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw P.name = "Invariant Violation", P;
              }
              m = e[g](a, g, v, s, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (E) {
              m = E;
            }
            m && !(m instanceof Error) && (J(x2), k("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", v || "React class", s, g, typeof m), J(null)), m instanceof Error && !(m.message in Pe) && (Pe[m.message] = true, J(x2), k("Failed %s type: %s", s, m.message), J(null));
          }
      }
    }
    var Rr2 = Array.isArray;
    function ie2(e) {
      return Rr2(e);
    }
    function Er3(e) {
      {
        var a = typeof Symbol == "function" && Symbol.toStringTag, s = a && e[Symbol.toStringTag] || e.constructor.name || "Object";
        return s;
      }
    }
    function Sr3(e) {
      try {
        return Ce2(e), false;
      } catch {
        return true;
      }
    }
    function Ce2(e) {
      return "" + e;
    }
    function Oe(e) {
      if (Sr3(e))
        return k("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Er3(e)), Ce2(e);
    }
    var V2 = L.ReactCurrentOwner, wr2 = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    }, Fe, Ne, se;
    se = {};
    function Tr2(e) {
      if (W2.call(e, "ref")) {
        var a = Object.getOwnPropertyDescriptor(e, "ref").get;
        if (a && a.isReactWarning)
          return false;
      }
      return e.ref !== void 0;
    }
    function kr2(e) {
      if (W2.call(e, "key")) {
        var a = Object.getOwnPropertyDescriptor(e, "key").get;
        if (a && a.isReactWarning)
          return false;
      }
      return e.key !== void 0;
    }
    function Pr3(e, a) {
      if (typeof e.ref == "string" && V2.current && a && V2.current.stateNode !== a) {
        var s = N(V2.current.type);
        se[s] || (k('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', N(V2.current.type), e.ref), se[s] = true);
      }
    }
    function _r2(e, a) {
      {
        var s = function() {
          Fe || (Fe = true, k("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", a));
        };
        s.isReactWarning = true, Object.defineProperty(e, "key", {
          get: s,
          configurable: true
        });
      }
    }
    function Cr3(e, a) {
      {
        var s = function() {
          Ne || (Ne = true, k("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", a));
        };
        s.isReactWarning = true, Object.defineProperty(e, "ref", {
          get: s,
          configurable: true
        });
      }
    }
    var Or2 = function(e, a, s, v, x2, j, g) {
      var m = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: n,
        // Built-in properties that belong on the element
        type: e,
        key: a,
        ref: s,
        props: g,
        // Record the component responsible for creating this element.
        _owner: j
      };
      return m._store = {}, Object.defineProperty(m._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      }), Object.defineProperty(m, "_self", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: v
      }), Object.defineProperty(m, "_source", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: x2
      }), Object.freeze && (Object.freeze(m.props), Object.freeze(m)), m;
    };
    function Fr2(e, a, s, v, x2) {
      {
        var j, g = {}, m = null, P = null;
        s !== void 0 && (Oe(s), m = "" + s), kr2(a) && (Oe(a.key), m = "" + a.key), Tr2(a) && (P = a.ref, Pr3(a, x2));
        for (j in a)
          W2.call(a, j) && !wr2.hasOwnProperty(j) && (g[j] = a[j]);
        if (e && e.defaultProps) {
          var E = e.defaultProps;
          for (j in E)
            g[j] === void 0 && (g[j] = E[j]);
        }
        if (m || P) {
          var S2 = typeof e == "function" ? e.displayName || e.name || "Unknown" : e;
          m && _r2(g, S2), P && Cr3(g, S2);
        }
        return Or2(e, m, P, x2, v, V2.current, g);
      }
    }
    var le2 = L.ReactCurrentOwner, De = L.ReactDebugCurrentFrame;
    function A(e) {
      if (e) {
        var a = e._owner, s = H2(e.type, e._source, a ? a.type : null);
        De.setExtraStackFrame(s);
      } else
        De.setExtraStackFrame(null);
    }
    var ue;
    ue = false;
    function ce(e) {
      return typeof e == "object" && e !== null && e.$$typeof === n;
    }
    function Me2() {
      {
        if (le2.current) {
          var e = N(le2.current.type);
          if (e)
            return `

Check the render method of \`` + e + "`.";
        }
        return "";
      }
    }
    function Nr3(e) {
      return "";
    }
    var Ie = {};
    function Dr3(e) {
      {
        var a = Me2();
        if (!a) {
          var s = typeof e == "string" ? e : e.displayName || e.name;
          s && (a = `

Check the top-level render call using <` + s + ">.");
        }
        return a;
      }
    }
    function Le(e, a) {
      {
        if (!e._store || e._store.validated || e.key != null)
          return;
        e._store.validated = true;
        var s = Dr3(a);
        if (Ie[s])
          return;
        Ie[s] = true;
        var v = "";
        e && e._owner && e._owner !== le2.current && (v = " It was passed a child from " + N(e._owner.type) + "."), A(e), k('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', s, v), A(null);
      }
    }
    function Ae(e, a) {
      {
        if (typeof e != "object")
          return;
        if (ie2(e))
          for (var s = 0; s < e.length; s++) {
            var v = e[s];
            ce(v) && Le(v, a);
          }
        else if (ce(e))
          e._store && (e._store.validated = true);
        else if (e) {
          var x2 = sr2(e);
          if (typeof x2 == "function" && x2 !== e.entries)
            for (var j = x2.call(e), g; !(g = j.next()).done; )
              ce(g.value) && Le(g.value, a);
        }
      }
    }
    function Mr2(e) {
      {
        var a = e.type;
        if (a == null || typeof a == "string")
          return;
        var s;
        if (typeof a == "function")
          s = a.propTypes;
        else if (typeof a == "object" && (a.$$typeof === d || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        a.$$typeof === w2))
          s = a.propTypes;
        else
          return;
        if (s) {
          var v = N(a);
          jr3(s, e.props, "prop", v, e);
        } else if (a.PropTypes !== void 0 && !ue) {
          ue = true;
          var x2 = N(a);
          k("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", x2 || "Unknown");
        }
        typeof a.getDefaultProps == "function" && !a.getDefaultProps.isReactClassApproved && k("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ir3(e) {
      {
        for (var a = Object.keys(e.props), s = 0; s < a.length; s++) {
          var v = a[s];
          if (v !== "children" && v !== "key") {
            A(e), k("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", v), A(null);
            break;
          }
        }
        e.ref !== null && (A(e), k("Invalid attribute `ref` supplied to `React.Fragment`."), A(null));
      }
    }
    var $e2 = {};
    function ze(e, a, s, v, x2, j) {
      {
        var g = br2(e);
        if (!g) {
          var m = "";
          (e === void 0 || typeof e == "object" && e !== null && Object.keys(e).length === 0) && (m += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var P = Nr3();
          P ? m += P : m += Me2();
          var E;
          e === null ? E = "null" : ie2(e) ? E = "array" : e !== void 0 && e.$$typeof === n ? (E = "<" + (N(e.type) || "Unknown") + " />", m = " Did you accidentally export a JSX literal instead of a component?") : E = typeof e, k("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", E, m);
        }
        var S2 = Fr2(e, a, s, x2, j);
        if (S2 == null)
          return S2;
        if (g) {
          var C2 = a.children;
          if (C2 !== void 0)
            if (v)
              if (ie2(C2)) {
                for (var $ = 0; $ < C2.length; $++)
                  Ae(C2[$], e);
                Object.freeze && Object.freeze(C2);
              } else
                k("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ae(C2, e);
        }
        if (W2.call(a, "key")) {
          var I = N(e), _ = Object.keys(a).filter(function(Vr2) {
            return Vr2 !== "key";
          }), de = _.length > 0 ? "{key: someKey, " + _.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!$e2[I + de]) {
            var Wr2 = _.length > 0 ? "{" + _.join(": ..., ") + ": ...}" : "{}";
            k(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, de, I, Wr2, I), $e2[I + de] = true;
          }
        }
        return e === o ? Ir3(S2) : Mr2(S2), S2;
      }
    }
    function Lr2(e, a, s) {
      return ze(e, a, s, true);
    }
    function Ar3(e, a, s) {
      return ze(e, a, s, false);
    }
    var $r2 = Ar3, zr2 = Lr2;
    Y2.Fragment = o, Y2.jsx = $r2, Y2.jsxs = zr2;
  }()), Y2;
}
false ? be2.exports = st() : be2.exports = lt();
var l = be2.exports;
var rr2 = (r2, n, t = false) => {
  const o = [];
  function i(u, f = "--bn") {
    for (const c in u) {
      const d = c.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), b = `${f}-${d}`;
      typeof u[c] != "object" ? (typeof u[c] == "number" && (u[c] = `${u[c]}px`), t ? n.style.removeProperty(b) : n.style.setProperty(b, u[c].toString())) : i(u[c], b);
    }
  }
  return i(r2), o;
};
var Be = (r2, n) => rr2(r2, n);
var ut = {
  colors: {
    editor: {
      text: void 0,
      background: void 0
    },
    menu: {
      text: void 0,
      background: void 0
    },
    tooltip: {
      text: void 0,
      background: void 0
    },
    hovered: {
      text: void 0,
      background: void 0
    },
    selected: {
      text: void 0,
      background: void 0
    },
    disabled: {
      text: void 0,
      background: void 0
    },
    shadow: void 0,
    border: void 0,
    sideMenu: void 0,
    highlights: {
      gray: {
        text: void 0,
        background: void 0
      },
      brown: {
        text: void 0,
        background: void 0
      },
      red: {
        text: void 0,
        background: void 0
      },
      orange: {
        text: void 0,
        background: void 0
      },
      yellow: {
        text: void 0,
        background: void 0
      },
      green: {
        text: void 0,
        background: void 0
      },
      blue: {
        text: void 0,
        background: void 0
      },
      purple: {
        text: void 0,
        background: void 0
      },
      pink: {
        text: void 0,
        background: void 0
      }
    }
  },
  borderRadius: void 0,
  fontFamily: void 0
};
var ct2 = (r2) => rr2(ut, r2, true);
var dt = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, children: o, id: i, columns: u, ...f } = r2;
  return Er(f), l.jsx(
    "div",
    {
      className: t,
      style: { gridTemplateColumns: `repeat(${u}, 1fr)` },
      ref: n,
      id: i,
      role: "grid",
      children: o
    }
  );
});
var ft = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, children: o, columns: i, ...u } = r2;
  return Er(u), l.jsx(
    Group,
    {
      className: t,
      style: { gridColumn: `1 / ${i + 1}` },
      ref: n,
      children: l.jsx(Group, { className: "bn-mt-suggestion-menu-item-title", children: o })
    }
  );
});
var vt2 = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, isSelected: o, onClick: i, item: u, id: f, ...c } = r2;
  Er(c);
  const d = (0, import_react5.useRef)(null);
  return (0, import_react5.useEffect)(() => {
    if (!d.current || !o)
      return;
    const b = Oi(
      d.current,
      document.querySelector(".bn-grid-suggestion-menu")
    );
    b === "top" ? d.current.scrollIntoView(true) : b === "bottom" && d.current.scrollIntoView(false);
  }, [o]), l.jsx(
    "div",
    {
      className: t,
      ref: mergeRefs(n, d),
      id: f,
      role: "option",
      onClick: i,
      "aria-selected": o || void 0,
      children: u.icon
    }
  );
});
var bt = (0, import_react5.forwardRef)((r2, n) => {
  const {
    className: t,
    children: o,
    // unused, using "dots" instead
    columns: i,
    ...u
  } = r2;
  return Er(u), l.jsx(
    Loader,
    {
      className: t,
      style: { gridColumn: `1 / ${i + 1}` },
      type: "dots",
      ref: n
    }
  );
});
var tr2 = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var Ye2 = import_react5.default.createContext && import_react5.default.createContext(tr2);
var mt = ["attr", "size", "title"];
function gt(r2, n) {
  if (r2 == null) return {};
  var t = pt(r2, n), o, i;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(r2);
    for (i = 0; i < u.length; i++)
      o = u[i], !(n.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(r2, o) && (t[o] = r2[o]);
  }
  return t;
}
function pt(r2, n) {
  if (r2 == null) return {};
  var t = {};
  for (var o in r2)
    if (Object.prototype.hasOwnProperty.call(r2, o)) {
      if (n.indexOf(o) >= 0) continue;
      t[o] = r2[o];
    }
  return t;
}
function ee2() {
  return ee2 = Object.assign ? Object.assign.bind() : function(r2) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var o in t)
        Object.prototype.hasOwnProperty.call(t, o) && (r2[o] = t[o]);
    }
    return r2;
  }, ee2.apply(this, arguments);
}
function Ue2(r2, n) {
  var t = Object.keys(r2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(r2);
    n && (o = o.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r2, i).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function re(r2) {
  for (var n = 1; n < arguments.length; n++) {
    var t = arguments[n] != null ? arguments[n] : {};
    n % 2 ? Ue2(Object(t), true).forEach(function(o) {
      ht(r2, o, t[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r2, Object.getOwnPropertyDescriptors(t)) : Ue2(Object(t)).forEach(function(o) {
      Object.defineProperty(r2, o, Object.getOwnPropertyDescriptor(t, o));
    });
  }
  return r2;
}
function ht(r2, n, t) {
  return n = xt(n), n in r2 ? Object.defineProperty(r2, n, { value: t, enumerable: true, configurable: true, writable: true }) : r2[n] = t, r2;
}
function xt(r2) {
  var n = yt(r2, "string");
  return typeof n == "symbol" ? n : n + "";
}
function yt(r2, n) {
  if (typeof r2 != "object" || !r2) return r2;
  var t = r2[Symbol.toPrimitive];
  if (t !== void 0) {
    var o = t.call(r2, n || "default");
    if (typeof o != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (n === "string" ? String : Number)(r2);
}
function nr2(r2) {
  return r2 && r2.map((n, t) => import_react5.default.createElement(n.tag, re({
    key: t
  }, n.attr), nr2(n.child)));
}
function or2(r2) {
  return (n) => import_react5.default.createElement(jt, ee2({
    attr: re({}, r2.attr)
  }, n), nr2(r2.child));
}
function jt(r2) {
  var n = (t) => {
    var {
      attr: o,
      size: i,
      title: u
    } = r2, f = gt(r2, mt), c = i || t.size || "1em", d;
    return t.className && (d = t.className), r2.className && (d = (d ? d + " " : "") + r2.className), import_react5.default.createElement("svg", ee2({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, t.attr, o, f, {
      className: d,
      style: re(re({
        color: r2.color || t.color
      }, t.style), r2.style),
      height: c,
      width: c,
      xmlns: "http://www.w3.org/2000/svg"
    }), u && import_react5.default.createElement("title", null, u), r2.children);
  };
  return Ye2 !== void 0 ? import_react5.default.createElement(Ye2.Consumer, null, (t) => n(t)) : n(tr2);
}
function Rt2(r2) {
  return or2({ tag: "svg", attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z", clipRule: "evenodd" }, child: [] }] })(r2);
}
function Et2(r2) {
  return or2({ tag: "svg", attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z", clipRule: "evenodd" }, child: [] }] })(r2);
}
var ar2 = (0, import_react5.createContext)(void 0);
var St2 = (0, import_react5.forwardRef)((r2, n) => {
  const {
    children: t,
    onOpenChange: o,
    position: i,
    sub: u,
    // not used
    ...f
  } = r2;
  Er(f);
  const [c, d] = (0, import_react5.useState)(false), b = (0, import_react5.useRef)(null), h = (0, import_react5.useRef)(), w2 = (0, import_react5.useCallback)(() => {
    h.current && clearTimeout(h.current), h.current = setTimeout(() => {
      d(false);
    }, 250);
  }, []), T = (0, import_react5.useCallback)(() => {
    h.current && clearTimeout(h.current), d(true);
  }, []);
  return l.jsx(
    ar2.Provider,
    {
      value: {
        onMenuMouseOver: T,
        onMenuMouseLeave: w2
      },
      children: l.jsx(
        Menu.Item,
        {
          className: "bn-menu-item bn-mt-sub-menu-item",
          ref: mergeRefs(n, b),
          onMouseOver: T,
          onMouseLeave: w2,
          children: l.jsx(
            Menu,
            {
              portalProps: {
                target: b.current ? b.current.parentElement : void 0
              },
              middlewares: { flip: true, shift: true, inline: false, size: true },
              trigger: "hover",
              opened: c,
              onClose: () => o == null ? void 0 : o(false),
              onOpen: () => o == null ? void 0 : o(true),
              position: i,
              children: t
            }
          )
        }
      )
    }
  );
});
var wt = (r2) => {
  const { children: n, onOpenChange: t, position: o, sub: i, ...u } = r2;
  return Er(u), i ? l.jsx(St2, { ...r2 }) : l.jsx(
    Menu,
    {
      withinPortal: false,
      middlewares: { flip: true, shift: true, inline: false, size: true },
      onClose: () => t == null ? void 0 : t(false),
      onOpen: () => t == null ? void 0 : t(true),
      position: o,
      children: n
    }
  );
};
var Tt2 = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, children: o, icon: i, checked: u, subTrigger: f, onClick: c, ...d } = r2;
  return Er(d, false), f ? l.jsxs("div", { ref: n, ...d, children: [
    o,
    l.jsx(Et2, { size: 15 })
  ] }) : l.jsx(
    Menu.Item,
    {
      className: t,
      ref: n,
      leftSection: i,
      rightSection: u ? l.jsx(CheckIcon, { size: 10 }) : u === false ? l.jsx("div", { className: "bn-tick-space" }) : null,
      onClick: c,
      ...d,
      children: o
    }
  );
});
var kt = (r2) => {
  const {
    children: n,
    sub: t,
    // unused
    ...o
  } = r2;
  return Er(o), l.jsx(Menu.Target, { children: n });
};
var Pt2 = (0, import_react5.forwardRef)((r2, n) => {
  const {
    className: t,
    children: o,
    sub: i,
    //unused
    ...u
  } = r2;
  Er(u);
  const f = (0, import_react5.useContext)(ar2);
  return l.jsx(
    Menu.Dropdown,
    {
      className: t,
      ref: n,
      onMouseOver: f == null ? void 0 : f.onMenuMouseOver,
      onMouseLeave: f == null ? void 0 : f.onMenuMouseLeave,
      children: o
    }
  );
});
var _t2 = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, ...o } = r2;
  return Er(o), l.jsx(Menu.Divider, { className: t, ref: n });
});
var Ct = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, children: o, ...i } = r2;
  return Er(i), l.jsx(Menu.Label, { className: t, ref: n, children: o });
});
var Ot2 = (0, import_react5.forwardRef)((r2, n) => {
  const {
    className: t,
    tabs: o,
    defaultOpenTab: i,
    openTab: u,
    setOpenTab: f,
    loading: c,
    ...d
  } = r2;
  return Er(d), l.jsx(Group, { className: t, ref: n, children: l.jsxs(
    Tabs,
    {
      value: u,
      defaultValue: i,
      onChange: f,
      children: [
        c && l.jsx(LoadingOverlay, { visible: c }),
        l.jsx(Tabs.List, { children: o.map((b) => l.jsx(
          Tabs.Tab,
          {
            "data-test": `${b.name.toLowerCase()}-tab`,
            value: b.name,
            children: b.name
          },
          b.name
        )) }),
        o.map((b) => l.jsx(Tabs.Panel, { value: b.name, children: b.tabPanel }, b.name))
      ]
    }
  ) });
});
var Ft = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, children: o, onClick: i, label: u, ...f } = r2;
  return Er(f), l.jsx(
    Button,
    {
      size: "xs",
      "aria-label": u,
      className: t,
      ref: n,
      onClick: i,
      ...f,
      children: o
    }
  );
});
var Nt2 = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, accept: o, value: i, placeholder: u, onChange: f, ...c } = r2;
  return Er(c), l.jsx(
    FileInput,
    {
      size: "xs",
      className: t,
      ref: n,
      accept: o,
      value: i,
      placeholder: u,
      onChange: f,
      ...c
    }
  );
});
var Dt = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, children: o, ...i } = r2;
  return Er(i), l.jsx("div", { className: t, ref: n, children: o });
});
var Mt2 = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, value: o, placeholder: i, onKeyDown: u, onChange: f, ...c } = r2;
  return Er(c), l.jsx(
    TextInput,
    {
      size: "xs",
      "data-test": "embed-input",
      className: t,
      ref: n,
      value: o,
      placeholder: i,
      onKeyDown: u,
      onChange: f
    }
  );
});
var It2 = (r2) => {
  const { children: n, opened: t, position: o, ...i } = r2;
  return Er(i), l.jsx(
    Popover,
    {
      withinPortal: false,
      zIndex: 1e4,
      opened: t,
      position: o,
      children: n
    }
  );
};
var Lt2 = (r2) => {
  const { children: n, ...t } = r2;
  return Er(t), l.jsx(PopoverTarget, { children: n });
};
var At = (0, import_react5.forwardRef)((r2, n) => {
  const {
    className: t,
    children: o,
    variant: i,
    // unused
    ...u
  } = r2;
  return Er(u), l.jsx(PopoverDropdown, { className: t, ref: n, children: o });
});
var $t2 = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, children: o, ...i } = r2;
  return Er(i, false), l.jsx(
    Group,
    {
      align: "center",
      gap: 0,
      className: t,
      ref: n,
      ...i,
      children: o
    }
  );
});
var zt = (0, import_react5.forwardRef)((r2, n) => {
  const {
    className: t,
    children: o,
    icon: i,
    onClick: u,
    onDragEnd: f,
    onDragStart: c,
    draggable: d,
    label: b,
    ...h
  } = r2;
  return Er(h, false), i ? l.jsx(
    ActionIcon,
    {
      size: 24,
      className: t,
      ref: n,
      onClick: u,
      onDragEnd: f,
      onDragStart: c,
      draggable: d,
      "aria-label": b,
      ...h,
      children: i
    }
  ) : l.jsx(
    Button,
    {
      className: t,
      ref: n,
      onClick: u,
      onDragEnd: f,
      onDragStart: c,
      draggable: d,
      "aria-label": b,
      ...h,
      children: o
    }
  );
});
var Wt = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, children: o, id: i, ...u } = r2;
  return Er(u), l.jsx(
    Stack,
    {
      gap: 0,
      className: t,
      ref: n,
      id: i,
      role: "listbox",
      children: o
    }
  );
});
var Vt2 = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, children: o, ...i } = r2;
  return Er(i), l.jsx(Group, { className: t, ref: n, children: l.jsx(Group, { className: "bn-mt-suggestion-menu-item-title", children: o }) });
});
var Bt2 = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, isSelected: o, onClick: i, item: u, id: f, ...c } = r2;
  Er(c);
  const d = (0, import_react5.useRef)(null);
  return (0, import_react5.useEffect)(() => {
    if (!d.current || !o)
      return;
    const b = Oi(
      d.current,
      document.querySelector(".bn-suggestion-menu")
    );
    b === "top" ? d.current.scrollIntoView(true) : b === "bottom" && d.current.scrollIntoView(false);
  }, [o]), l.jsxs(
    Group,
    {
      gap: 0,
      className: t,
      ref: mergeRefs(n, d),
      id: f,
      role: "option",
      onClick: i,
      "aria-selected": o || void 0,
      children: [
        u.icon && l.jsx(
          Group,
          {
            className: "bn-mt-suggestion-menu-item-section",
            "data-position": "left",
            children: u.icon
          }
        ),
        l.jsxs(Stack, { gap: 0, className: "bn-mt-suggestion-menu-item-body", children: [
          l.jsx(Text, { className: "bn-mt-suggestion-menu-item-title", children: u.title }),
          l.jsx(Text, { className: "bn-mt-suggestion-menu-item-subtitle", children: u.subtext })
        ] }),
        u.badge && l.jsx(
          Group,
          {
            "data-position": "right",
            className: "bn-mt-suggestion-menu-item-section",
            children: l.jsx(Badge, { size: "xs", children: u.badge })
          }
        )
      ]
    }
  );
});
var Yt = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, children: o, ...i } = r2;
  return Er(i), l.jsx(Group, { className: t, ref: n, children: o });
});
var Ut = (0, import_react5.forwardRef)((r2, n) => {
  const {
    className: t,
    children: o,
    // unused, using "dots" instead
    ...i
  } = r2;
  return Er(i), l.jsx(Loader, { className: t, type: "dots", ref: n });
});
var Gt2 = (0, import_react5.forwardRef)((r2, n) => {
  const {
    className: t,
    children: o,
    draggable: i,
    onDragStart: u,
    onDragEnd: f,
    style: c,
    label: d,
    ...b
  } = r2;
  return Er(b, false), l.jsx(
    Button,
    {
      className: t,
      ref: n,
      "aria-label": d,
      draggable: i,
      onDragStart: u,
      onDragEnd: f,
      style: c,
      ...b,
      children: o
    }
  );
});
var Kt = (0, import_react5.forwardRef)((r2, n) => {
  const {
    className: t,
    name: o,
    label: i,
    icon: u,
    value: f,
    autoFocus: c,
    placeholder: d,
    onKeyDown: b,
    onChange: h,
    onSubmit: w2,
    ...T
  } = r2;
  return Er(T), l.jsx(
    TextInput,
    {
      size: "xs",
      className: t,
      ref: n,
      name: o,
      label: i,
      leftSection: u,
      value: f,
      autoFocus: c,
      "data-autofocus": c ? "true" : void 0,
      placeholder: d,
      onKeyDown: b,
      onChange: h,
      onSubmit: w2
    }
  );
});
var Ge2 = (0, import_react5.forwardRef)(
  (r2, n) => {
    const { className: t, children: o, onMouseEnter: i, onMouseLeave: u, ...f } = r2;
    Er(f);
    const { ref: c, focused: d } = useFocusWithin(), b = useFocusTrap(d), h = mergeRefs(n, c, b);
    return l.jsx(
      Group,
      {
        className: t,
        ref: h,
        role: "toolbar",
        onMouseEnter: i,
        onMouseLeave: u,
        children: o
      }
    );
  }
);
var qt = (r2) => l.jsxs(Stack, { gap: 0, className: "bn-tooltip", children: [
  l.jsx(Text, { size: "sm", children: r2.mainTooltip }),
  r2.secondaryTooltip && l.jsx(Text, { size: "xs", children: r2.secondaryTooltip })
] });
var Ke2 = (0, import_react5.forwardRef)(
  (r2, n) => {
    const {
      className: t,
      children: o,
      mainTooltip: i,
      secondaryTooltip: u,
      icon: f,
      isSelected: c,
      isDisabled: d,
      onClick: b,
      label: h,
      ...w2
    } = r2;
    return Er(w2, false), l.jsx(
      Tooltip,
      {
        withinPortal: false,
        label: l.jsx(
          qt,
          {
            mainTooltip: i,
            secondaryTooltip: u
          }
        ),
        children: o ? l.jsx(
          Button,
          {
            "aria-label": h,
            className: t,
            onMouseDown: (T) => {
              Cr() && T.currentTarget.focus();
            },
            onClick: b,
            "aria-pressed": c,
            "data-selected": c || void 0,
            "data-test": i.slice(0, 1).toLowerCase() + i.replace(/\s+/g, "").slice(1),
            size: "xs",
            disabled: d || false,
            ref: n,
            ...w2,
            children: o
          }
        ) : l.jsx(
          ActionIcon,
          {
            className: t,
            "aria-label": h,
            onMouseDown: (T) => {
              Cr() && T.currentTarget.focus();
            },
            onClick: b,
            "aria-pressed": c,
            "data-selected": c || void 0,
            "data-test": i.slice(0, 1).toLowerCase() + i.replace(/\s+/g, "").slice(1),
            size: 30,
            disabled: d || false,
            ref: n,
            ...w2,
            children: f
          }
        )
      }
    );
  }
);
var Ht = (0, import_react5.forwardRef)((r2, n) => {
  const { className: t, items: o, isDisabled: i, ...u } = r2;
  Er(u);
  const f = o.filter((c) => c.isSelected)[0];
  return f ? l.jsxs(
    Menu,
    {
      withinPortal: false,
      transitionProps: {
        exitDuration: 0
      },
      disabled: i,
      middlewares: { flip: true, shift: true, inline: false, size: true },
      children: [
        l.jsx(Menu.Target, { children: l.jsx(
          Button,
          {
            onMouseDown: (c) => {
              Cr() && c.currentTarget.focus();
            },
            leftSection: f.icon,
            rightSection: l.jsx(Rt2, {}),
            size: "xs",
            variant: "subtle",
            disabled: i,
            children: f.text
          }
        ) }),
        l.jsx(Menu.Dropdown, { className: t, ref: n, children: o.map((c) => l.jsx(
          Menu.Item,
          {
            onClick: c.onClick,
            leftSection: c.icon,
            rightSection: c.isSelected ? l.jsx(CheckIcon, { size: 10, className: "bn-tick-icon" }) : (
              // Ensures space for tick even if item isn't currently selected.
              l.jsx("div", { className: "bn-tick-space" })
            ),
            disabled: c.isDisabled,
            children: c.text
          },
          c.text
        )) })
      ]
    }
  ) : null;
});
var y2 = [
  "#FFFFFF",
  "#EFEFEF",
  "#CFCFCF",
  "#AFAFAF",
  "#7F7F7F",
  "#3F3F3F",
  "#1F1F1F",
  "#161616",
  "#0F0F0F",
  "#000000"
];
var qe = {
  colors: {
    editor: {
      text: y2[5],
      background: y2[0]
    },
    menu: {
      text: y2[5],
      background: y2[0]
    },
    tooltip: {
      text: y2[5],
      background: y2[1]
    },
    hovered: {
      text: y2[5],
      background: y2[1]
    },
    selected: {
      text: y2[0],
      background: y2[5]
    },
    disabled: {
      text: y2[3],
      background: y2[1]
    },
    shadow: y2[2],
    border: y2[1],
    sideMenu: y2[2],
    highlights: {
      gray: {
        text: "#9b9a97",
        background: "#ebeced"
      },
      brown: {
        text: "#64473a",
        background: "#e9e5e3"
      },
      red: {
        text: "#e03e3e",
        background: "#fbe4e4"
      },
      orange: {
        text: "#d9730d",
        background: "#f6e9d9"
      },
      yellow: {
        text: "#dfab01",
        background: "#fbf3db"
      },
      green: {
        text: "#4d6461",
        background: "#ddedea"
      },
      blue: {
        text: "#0b6e99",
        background: "#ddebf1"
      },
      purple: {
        text: "#6940a5",
        background: "#eae4f2"
      },
      pink: {
        text: "#ad1a72",
        background: "#f4dfeb"
      }
    }
  },
  borderRadius: 6,
  fontFamily: '"Inter", "SF Pro Display", -apple-system, BlinkMacSystemFont, "Open Sans", "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif'
};
var nn2 = {
  colors: {
    editor: {
      text: y2[2],
      background: y2[6]
    },
    menu: {
      text: y2[2],
      background: y2[6]
    },
    tooltip: {
      text: y2[2],
      background: y2[7]
    },
    hovered: {
      text: y2[2],
      background: y2[7]
    },
    selected: {
      text: y2[2],
      background: y2[8]
    },
    disabled: {
      text: y2[5],
      background: y2[7]
    },
    shadow: y2[8],
    border: y2[7],
    sideMenu: y2[4],
    highlights: {
      gray: {
        text: "#bebdb8",
        background: "#9b9a97"
      },
      brown: {
        text: "#8e6552",
        background: "#64473a"
      },
      red: {
        text: "#ec4040",
        background: "#be3434"
      },
      orange: {
        text: "#e3790d",
        background: "#b7600a"
      },
      yellow: {
        text: "#dfab01",
        background: "#b58b00"
      },
      green: {
        text: "#6b8b87",
        background: "#4d6461"
      },
      blue: {
        text: "#0e87bc",
        background: "#0b6e99"
      },
      purple: {
        text: "#8552d7",
        background: "#6940a5"
      },
      pink: {
        text: "#da208f",
        background: "#ad1a72"
      }
    }
  },
  borderRadius: qe.borderRadius,
  fontFamily: qe.fontFamily
};
var Jt2 = {
  FormattingToolbar: {
    Root: Ge2,
    Button: Ke2,
    Select: Ht
  },
  FilePanel: {
    Root: Ot2,
    Button: Ft,
    FileInput: Nt2,
    TabPanel: Dt,
    TextInput: Mt2
  },
  GridSuggestionMenu: {
    Root: dt,
    Item: vt2,
    EmptyItem: ft,
    Loader: bt
  },
  LinkToolbar: {
    Root: Ge2,
    Button: Ke2
  },
  SideMenu: {
    Root: $t2,
    Button: zt
  },
  SuggestionMenu: {
    Root: Wt,
    Item: Bt2,
    EmptyItem: Vt2,
    Label: Yt,
    Loader: Ut
  },
  TableHandle: {
    Root: Gt2
  },
  Generic: {
    Form: {
      Root: (r2) => l.jsx("div", { children: r2.children }),
      TextInput: Kt
    },
    Menu: {
      Root: wt,
      Trigger: kt,
      Dropdown: Pt2,
      Divider: _t2,
      Label: Ct,
      Item: Tt2
    },
    Popover: {
      Root: It2,
      Trigger: Lt2,
      Content: At
    }
  }
};
var Xt2 = {
  // Removes button press effect
  activeClassName: ""
};
var on2 = (r2) => {
  const { className: n, theme: t, ...o } = r2, i = z2(), u = li(), f = (i == null ? void 0 : i.colorSchemePreference) || u, c = (0, import_react5.useCallback)(
    (d) => {
      if (d && (ct2(d), typeof t == "object")) {
        if ("light" in t && "dark" in t) {
          Be(
            t[f === "dark" ? "dark" : "light"],
            d
          );
          return;
        }
        Be(t, d);
        return;
      }
    },
    [f, t]
  );
  return l.jsx(Mo.Provider, { value: Jt2, children: l.jsx(
    MantineProvider,
    {
      theme: Xt2,
      cssVariablesSelector: ".bn-mantine",
      getRootElement: () => {
      },
      children: l.jsx(
        Si,
        {
          className: z("bn-mantine", n || ""),
          theme: typeof t == "object" ? void 0 : t,
          ...o,
          ref: c
        }
      )
    }
  ) });
};
export {
  on2 as BlockNoteView,
  Be as applyBlockNoteCSSVariablesFromTheme,
  Jt2 as components,
  nn2 as darkDefaultTheme,
  y2 as defaultColorScheme,
  qe as lightDefaultTheme,
  ct2 as removeBlockNoteCSSVariables
};
/*! Bundled license information:

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@blocknote/react/dist/blocknote-react.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@blocknote/react/dist/blocknote-react.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@blocknote/mantine/dist/blocknote-mantine.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@blocknote/mantine/dist/blocknote-mantine.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@blocknote_mantine.js.map
