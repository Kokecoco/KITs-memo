{"version":3,"file":"index-BJQJQbXe.js","sources":["../../node_modules/micromark-util-sanitize-uri/index.js","../../node_modules/mdast-util-to-hast/lib/handlers/blockquote.js","../../node_modules/mdast-util-to-hast/lib/handlers/break.js","../../node_modules/mdast-util-to-hast/lib/handlers/code.js","../../node_modules/mdast-util-to-hast/lib/handlers/delete.js","../../node_modules/mdast-util-to-hast/lib/handlers/emphasis.js","../../node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js","../../node_modules/mdast-util-to-hast/lib/handlers/footnote.js","../../node_modules/mdast-util-to-hast/lib/handlers/heading.js","../../node_modules/mdast-util-to-hast/lib/handlers/html.js","../../node_modules/mdast-util-to-hast/lib/revert.js","../../node_modules/mdast-util-to-hast/lib/handlers/image-reference.js","../../node_modules/mdast-util-to-hast/lib/handlers/image.js","../../node_modules/mdast-util-to-hast/lib/handlers/inline-code.js","../../node_modules/mdast-util-to-hast/lib/handlers/link-reference.js","../../node_modules/mdast-util-to-hast/lib/handlers/link.js","../../node_modules/mdast-util-to-hast/lib/handlers/list-item.js","../../node_modules/mdast-util-to-hast/lib/handlers/list.js","../../node_modules/mdast-util-to-hast/lib/handlers/paragraph.js","../../node_modules/mdast-util-to-hast/lib/handlers/root.js","../../node_modules/mdast-util-to-hast/lib/handlers/strong.js","../../node_modules/unist-util-position/lib/index.js","../../node_modules/mdast-util-to-hast/lib/handlers/table.js","../../node_modules/mdast-util-to-hast/lib/handlers/table-row.js","../../node_modules/mdast-util-to-hast/lib/handlers/table-cell.js","../../node_modules/trim-lines/index.js","../../node_modules/mdast-util-to-hast/lib/handlers/text.js","../../node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js","../../node_modules/mdast-util-to-hast/lib/handlers/index.js","../../node_modules/unist-util-generated/lib/index.js","../../node_modules/mdast-util-definitions/lib/index.js","../../node_modules/mdast-util-to-hast/lib/state.js","../../node_modules/mdast-util-to-hast/lib/footer.js","../../node_modules/mdast-util-to-hast/lib/index.js","../../node_modules/remark-rehype/lib/index.js"],"sourcesContent":["import {asciiAlphanumeric} from 'micromark-util-character'\nimport {encode} from 'micromark-util-encode'\n/**\n * Make a value safe for injection as a URL.\n *\n * This encodes unsafe characters with percent-encoding and skips already\n * encoded sequences (see `normalizeUri`).\n * Further unsafe characters are encoded as character references (see\n * `micromark-util-encode`).\n *\n * A regex of allowed protocols can be given, in which case the URL is\n * sanitized.\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`, or\n * `/^https?$/i` for `img[src]` (this is what `github.com` allows).\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\n * as a dangerous example, `javascript:`), the value is ignored.\n *\n * @param {string | undefined} url\n *   URI to sanitize.\n * @param {RegExp | null | undefined} [protocol]\n *   Allowed protocols.\n * @returns {string}\n *   Sanitized URI.\n */\nexport function sanitizeUri(url, protocol) {\n  const value = encode(normalizeUri(url || ''))\n  if (!protocol) {\n    return value\n  }\n  const colon = value.indexOf(':')\n  const questionMark = value.indexOf('?')\n  const numberSign = value.indexOf('#')\n  const slash = value.indexOf('/')\n  if (\n    // If there is no protocol, it’s relative.\n    colon < 0 ||\n    // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign) ||\n    // It is a protocol, it should be allowed.\n    protocol.test(value.slice(0, colon))\n  ) {\n    return value\n  }\n  return ''\n}\n\n/**\n * Normalize a URL.\n *\n * Encode unsafe characters with percent-encoding, skipping already encoded\n * sequences.\n *\n * @param {string} value\n *   URI to normalize.\n * @returns {string}\n *   Normalized URI.\n */\nexport function normalizeUri(value) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n  let start = 0\n  let skip = 0\n  while (++index < value.length) {\n    const code = value.charCodeAt(index)\n    /** @type {string} */\n    let replace = ''\n\n    // A correct percent encoded value.\n    if (\n      code === 37 &&\n      asciiAlphanumeric(value.charCodeAt(index + 1)) &&\n      asciiAlphanumeric(value.charCodeAt(index + 2))\n    ) {\n      skip = 2\n    }\n    // ASCII.\n    else if (code < 128) {\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n        replace = String.fromCharCode(code)\n      }\n    }\n    // Astral.\n    else if (code > 55295 && code < 57344) {\n      const next = value.charCodeAt(index + 1)\n\n      // A correct surrogate pair.\n      if (code < 56320 && next > 56319 && next < 57344) {\n        replace = String.fromCharCode(code, next)\n        skip = 1\n      }\n      // Lone surrogate.\n      else {\n        replace = '\\uFFFD'\n      }\n    }\n    // Unicode.\n    else {\n      replace = String.fromCharCode(code)\n    }\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace))\n      start = index + skip + 1\n      replace = ''\n    }\n    if (skip) {\n      index += skip\n      skip = 0\n    }\n  }\n  return result.join('') + value.slice(start)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `blockquote` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Blockquote} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function blockquote(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'blockquote',\n    properties: {},\n    children: state.wrap(state.all(node), true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `break` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Break} node\n *   mdast node.\n * @returns {Array<Element | Text>}\n *   hast element content.\n */\nexport function hardBreak(state, node) {\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'br', properties: {}, children: []}\n  state.patch(node, result)\n  return [state.applyData(node, result), {type: 'text', value: '\\n'}]\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../state.js').State} State\n\n */\n\n/**\n * Turn an mdast `code` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Code} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function code(state, node) {\n  const value = node.value ? node.value + '\\n' : ''\n  // To do: next major, use `node.lang` w/o regex, the splitting’s been going\n  // on for years in remark now.\n  const lang = node.lang ? node.lang.match(/^[^ \\t]+(?=[ \\t]|$)/) : null\n  /** @type {Properties} */\n  const properties = {}\n\n  if (lang) {\n    properties.className = ['language-' + lang]\n  }\n\n  // Create `<code>`.\n  /** @type {Element} */\n  let result = {\n    type: 'element',\n    tagName: 'code',\n    properties,\n    children: [{type: 'text', value}]\n  }\n\n  if (node.meta) {\n    result.data = {meta: node.meta}\n  }\n\n  state.patch(node, result)\n  result = state.applyData(node, result)\n\n  // Create `<pre>`.\n  result = {type: 'element', tagName: 'pre', properties: {}, children: [result]}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Delete} Delete\n * @typedef {import('../state.js').State} State\n\n */\n\n/**\n * Turn an mdast `delete` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Delete} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strikethrough(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'del',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `emphasis` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Emphasis} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function emphasis(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'em',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('hast').Element} Element\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `footnoteReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {FootnoteReference} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function footnoteReference(state, node) {\n  const id = String(node.identifier).toUpperCase()\n  const safeId = normalizeUri(id.toLowerCase())\n  const index = state.footnoteOrder.indexOf(id)\n  /** @type {number} */\n  let counter\n\n  if (index === -1) {\n    state.footnoteOrder.push(id)\n    state.footnoteCounts[id] = 1\n    counter = state.footnoteOrder.length\n  } else {\n    state.footnoteCounts[id]++\n    counter = index + 1\n  }\n\n  const reuseCounter = state.footnoteCounts[id]\n\n  /** @type {Element} */\n  const link = {\n    type: 'element',\n    tagName: 'a',\n    properties: {\n      href: '#' + state.clobberPrefix + 'fn-' + safeId,\n      id:\n        state.clobberPrefix +\n        'fnref-' +\n        safeId +\n        (reuseCounter > 1 ? '-' + reuseCounter : ''),\n      dataFootnoteRef: true,\n      ariaDescribedBy: ['footnote-label']\n    },\n    children: [{type: 'text', value: String(counter)}]\n  }\n  state.patch(node, link)\n\n  /** @type {Element} */\n  const sup = {\n    type: 'element',\n    tagName: 'sup',\n    properties: {},\n    children: [link]\n  }\n  state.patch(node, sup)\n  return state.applyData(node, sup)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Footnote} Footnote\n * @typedef {import('../state.js').State} State\n */\n\nimport {footnoteReference} from './footnote-reference.js'\n\n// To do: when both:\n// * <https://github.com/micromark/micromark-extension-footnote>\n// * <https://github.com/syntax-tree/mdast-util-footnote>\n// …are archived, remove this (also from mdast).\n// These inline notes are not used in GFM.\n\n/**\n * Turn an mdast `footnote` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Footnote} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function footnote(state, node) {\n  const footnoteById = state.footnoteById\n  let no = 1\n\n  while (no in footnoteById) no++\n\n  const identifier = String(no)\n\n  footnoteById[identifier] = {\n    type: 'footnoteDefinition',\n    identifier,\n    children: [{type: 'paragraph', children: node.children}],\n    position: node.position\n  }\n\n  return footnoteReference(state, {\n    type: 'footnoteReference',\n    identifier,\n    position: node.position\n  })\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `heading` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Heading} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function heading(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'h' + node.depth,\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').HTML} Html\n * @typedef {import('../state.js').State} State\n * @typedef {import('../../index.js').Raw} Raw\n */\n\n/**\n * Turn an mdast `html` node into hast (`raw` node in dangerous mode, otherwise\n * nothing).\n *\n * @param {State} state\n *   Info passed around.\n * @param {Html} node\n *   mdast node.\n * @returns {Raw | Element | null}\n *   hast node.\n */\nexport function html(state, node) {\n  if (state.dangerous) {\n    /** @type {Raw} */\n    const result = {type: 'raw', value: node.value}\n    state.patch(node, result)\n    return state.applyData(node, result)\n  }\n\n  // To do: next major: return `undefined`.\n  return null\n}\n","/**\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Reference} Reference\n * @typedef {import('mdast').Root} Root\n *\n * @typedef {import('./state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Reference>} References\n */\n\n// To do: next major: always return array.\n\n/**\n * Return the content of a reference without definition as plain text.\n *\n * @param {State} state\n *   Info passed around.\n * @param {References} node\n *   Reference node (image, link).\n * @returns {ElementContent | Array<ElementContent>}\n *   hast content.\n */\nexport function revert(state, node) {\n  const subtype = node.referenceType\n  let suffix = ']'\n\n  if (subtype === 'collapsed') {\n    suffix += '[]'\n  } else if (subtype === 'full') {\n    suffix += '[' + (node.label || node.identifier) + ']'\n  }\n\n  if (node.type === 'imageReference') {\n    return {type: 'text', value: '![' + node.alt + suffix}\n  }\n\n  const contents = state.all(node)\n  const head = contents[0]\n\n  if (head && head.type === 'text') {\n    head.value = '[' + head.value\n  } else {\n    contents.unshift({type: 'text', value: '['})\n  }\n\n  const tail = contents[contents.length - 1]\n\n  if (tail && tail.type === 'text') {\n    tail.value += suffix\n  } else {\n    contents.push({type: 'text', value: suffix})\n  }\n\n  return contents\n}\n","/**\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `imageReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ImageReference} node\n *   mdast node.\n * @returns {ElementContent | Array<ElementContent>}\n *   hast node.\n */\nexport function imageReference(state, node) {\n  const def = state.definition(node.identifier)\n\n  if (!def) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(def.url || ''), alt: node.alt}\n\n  if (def.title !== null && def.title !== undefined) {\n    properties.title = def.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `image` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Image} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function image(state, node) {\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(node.url)}\n\n  if (node.alt !== null && node.alt !== undefined) {\n    properties.alt = node.alt\n  }\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `inlineCode` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {InlineCode} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function inlineCode(state, node) {\n  /** @type {Text} */\n  const text = {type: 'text', value: node.value.replace(/\\r?\\n|\\r/g, ' ')}\n  state.patch(node, text)\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'code',\n    properties: {},\n    children: [text]\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `linkReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {LinkReference} node\n *   mdast node.\n * @returns {ElementContent | Array<ElementContent>}\n *   hast node.\n */\nexport function linkReference(state, node) {\n  const def = state.definition(node.identifier)\n\n  if (!def) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(def.url || '')}\n\n  if (def.title !== null && def.title !== undefined) {\n    properties.title = def.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `link` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Link} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function link(state, node) {\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(node.url)}\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */\n\n/**\n * Turn an mdast `listItem` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ListItem} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function listItem(state, node, parent) {\n  const results = state.all(node)\n  const loose = parent ? listLoose(parent) : listItemLoose(node)\n  /** @type {Properties} */\n  const properties = {}\n  /** @type {Array<ElementContent>} */\n  const children = []\n\n  if (typeof node.checked === 'boolean') {\n    const head = results[0]\n    /** @type {Element} */\n    let paragraph\n\n    if (head && head.type === 'element' && head.tagName === 'p') {\n      paragraph = head\n    } else {\n      paragraph = {type: 'element', tagName: 'p', properties: {}, children: []}\n      results.unshift(paragraph)\n    }\n\n    if (paragraph.children.length > 0) {\n      paragraph.children.unshift({type: 'text', value: ' '})\n    }\n\n    paragraph.children.unshift({\n      type: 'element',\n      tagName: 'input',\n      properties: {type: 'checkbox', checked: node.checked, disabled: true},\n      children: []\n    })\n\n    // According to github-markdown-css, this class hides bullet.\n    // See: <https://github.com/sindresorhus/github-markdown-css>.\n    properties.className = ['task-list-item']\n  }\n\n  let index = -1\n\n  while (++index < results.length) {\n    const child = results[index]\n\n    // Add eols before nodes, except if this is a loose, first paragraph.\n    if (\n      loose ||\n      index !== 0 ||\n      child.type !== 'element' ||\n      child.tagName !== 'p'\n    ) {\n      children.push({type: 'text', value: '\\n'})\n    }\n\n    if (child.type === 'element' && child.tagName === 'p' && !loose) {\n      children.push(...child.children)\n    } else {\n      children.push(child)\n    }\n  }\n\n  const tail = results[results.length - 1]\n\n  // Add a final eol.\n  if (tail && (loose || tail.type !== 'element' || tail.tagName !== 'p')) {\n    children.push({type: 'text', value: '\\n'})\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'li', properties, children}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * @param {Parents} node\n * @return {Boolean}\n */\nfunction listLoose(node) {\n  let loose = false\n  if (node.type === 'list') {\n    loose = node.spread || false\n    const children = node.children\n    let index = -1\n\n    while (!loose && ++index < children.length) {\n      loose = listItemLoose(children[index])\n    }\n  }\n\n  return loose\n}\n\n/**\n * @param {ListItem} node\n * @return {Boolean}\n */\nfunction listItemLoose(node) {\n  const spread = node.spread\n\n  return spread === undefined || spread === null\n    ? node.children.length > 1\n    : spread\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').List} List\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `list` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {List} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function list(state, node) {\n  /** @type {Properties} */\n  const properties = {}\n  const results = state.all(node)\n  let index = -1\n\n  if (typeof node.start === 'number' && node.start !== 1) {\n    properties.start = node.start\n  }\n\n  // Like GitHub, add a class for custom styling.\n  while (++index < results.length) {\n    const child = results[index]\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'li' &&\n      child.properties &&\n      Array.isArray(child.properties.className) &&\n      child.properties.className.includes('task-list-item')\n    ) {\n      properties.className = ['contains-task-list']\n      break\n    }\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: node.ordered ? 'ol' : 'ul',\n    properties,\n    children: state.wrap(results, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `paragraph` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Paragraph} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function paragraph(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'p',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `root` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastRoot} node\n *   mdast node.\n * @returns {HastRoot | HastElement}\n *   hast node.\n */\nexport function root(state, node) {\n  /** @type {HastRoot} */\n  const result = {type: 'root', children: state.wrap(state.all(node))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `strong` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Strong} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strong(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'strong',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Get the starting point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointStart = point('start')\n\n/**\n * Get the ending point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointEnd = point('end')\n\n/**\n * Get the positional info of `node`.\n *\n * @param {NodeLike | Node | null | undefined} [node]\n *   Node.\n * @returns {Position}\n *   Position.\n */\nexport function position(node) {\n  return {start: pointStart(node), end: pointEnd(node)}\n}\n\n/**\n * Get the positional info of `node`.\n *\n * @param {'start' | 'end'} type\n *   Side.\n * @returns\n *   Getter.\n */\nfunction point(type) {\n  return point\n\n  /**\n   * Get the point info of `node` at a bound side.\n   *\n   * @param {NodeLike | Node | null | undefined} [node]\n   * @returns {Point}\n   */\n  function point(node) {\n    const point = (node && node.position && node.position[type]) || {}\n\n    // To do: next major: don’t return points when invalid.\n    return {\n      // @ts-expect-error: in practice, null is allowed.\n      line: point.line || null,\n      // @ts-expect-error: in practice, null is allowed.\n      column: point.column || null,\n      // @ts-expect-error: in practice, null is allowed.\n      offset: point.offset > -1 ? point.offset : null\n    }\n  }\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Table} Table\n * @typedef {import('../state.js').State} State\n */\n\nimport {pointStart, pointEnd} from 'unist-util-position'\n\n/**\n * Turn an mdast `table` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Table} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function table(state, node) {\n  const rows = state.all(node)\n  const firstRow = rows.shift()\n  /** @type {Array<Element>} */\n  const tableContent = []\n\n  if (firstRow) {\n    /** @type {Element} */\n    const head = {\n      type: 'element',\n      tagName: 'thead',\n      properties: {},\n      children: state.wrap([firstRow], true)\n    }\n    state.patch(node.children[0], head)\n    tableContent.push(head)\n  }\n\n  if (rows.length > 0) {\n    /** @type {Element} */\n    const body = {\n      type: 'element',\n      tagName: 'tbody',\n      properties: {},\n      children: state.wrap(rows, true)\n    }\n\n    const start = pointStart(node.children[1])\n    const end = pointEnd(node.children[node.children.length - 1])\n    if (start.line && end.line) body.position = {start, end}\n    tableContent.push(body)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'table',\n    properties: {},\n    children: state.wrap(tableContent, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */\n\n/**\n * Turn an mdast `tableRow` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableRow} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function tableRow(state, node, parent) {\n  const siblings = parent ? parent.children : undefined\n  // Generate a body row when without parent.\n  const rowIndex = siblings ? siblings.indexOf(node) : 1\n  const tagName = rowIndex === 0 ? 'th' : 'td'\n  const align = parent && parent.type === 'table' ? parent.align : undefined\n  const length = align ? align.length : node.children.length\n  let cellIndex = -1\n  /** @type {Array<ElementContent>} */\n  const cells = []\n\n  while (++cellIndex < length) {\n    // Note: can also be undefined.\n    const cell = node.children[cellIndex]\n    /** @type {Properties} */\n    const properties = {}\n    const alignValue = align ? align[cellIndex] : undefined\n\n    if (alignValue) {\n      properties.align = alignValue\n    }\n\n    /** @type {Element} */\n    let result = {type: 'element', tagName, properties, children: []}\n\n    if (cell) {\n      result.children = state.all(cell)\n      state.patch(cell, result)\n      result = state.applyData(node, result)\n    }\n\n    cells.push(result)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'tr',\n    properties: {},\n    children: state.wrap(cells, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `tableCell` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableCell} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function tableCell(state, node) {\n  // Note: this function is normally not called: see `table-row` for how rows\n  // and their cells are compiled.\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'td', // Assume body cell.\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","const tab = 9 /* `\\t` */\nconst space = 32 /* ` ` */\n\n/**\n * Remove initial and final spaces and tabs at the line breaks in `value`.\n * Does not trim initial and final spaces and tabs of the value itself.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Trimmed value.\n */\nexport function trimLines(value) {\n  const source = String(value)\n  const search = /\\r?\\n|\\r/g\n  let match = search.exec(source)\n  let last = 0\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (match) {\n    lines.push(\n      trimLine(source.slice(last, match.index), last > 0, true),\n      match[0]\n    )\n\n    last = match.index + match[0].length\n    match = search.exec(source)\n  }\n\n  lines.push(trimLine(source.slice(last), last > 0, false))\n\n  return lines.join('')\n}\n\n/**\n * @param {string} value\n *   Line to trim.\n * @param {boolean} start\n *   Whether to trim the start of the line.\n * @param {boolean} end\n *   Whether to trim the end of the line.\n * @returns {string}\n *   Trimmed line.\n */\nfunction trimLine(value, start, end) {\n  let startIndex = 0\n  let endIndex = value.length\n\n  if (start) {\n    let code = value.codePointAt(startIndex)\n\n    while (code === tab || code === space) {\n      startIndex++\n      code = value.codePointAt(startIndex)\n    }\n  }\n\n  if (end) {\n    let code = value.codePointAt(endIndex - 1)\n\n    while (code === tab || code === space) {\n      endIndex--\n      code = value.codePointAt(endIndex - 1)\n    }\n  }\n\n  return endIndex > startIndex ? value.slice(startIndex, endIndex) : ''\n}\n","/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Text} HastText\n * @typedef {import('mdast').Text} MdastText\n * @typedef {import('../state.js').State} State\n */\n\nimport {trimLines} from 'trim-lines'\n\n/**\n * Turn an mdast `text` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastText} node\n *   mdast node.\n * @returns {HastText | HastElement}\n *   hast node.\n */\nexport function text(state, node) {\n  /** @type {HastText} */\n  const result = {type: 'text', value: trimLines(String(node.value))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `thematicBreak` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ThematicBreak} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function thematicBreak(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'hr',\n    properties: {},\n    children: []\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {strikethrough} from './delete.js'\nimport {emphasis} from './emphasis.js'\nimport {footnoteReference} from './footnote-reference.js'\nimport {footnote} from './footnote.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {imageReference} from './image-reference.js'\nimport {image} from './image.js'\nimport {inlineCode} from './inline-code.js'\nimport {linkReference} from './link-reference.js'\nimport {link} from './link.js'\nimport {listItem} from './list-item.js'\nimport {list} from './list.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {table} from './table.js'\nimport {tableRow} from './table-row.js'\nimport {tableCell} from './table-cell.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default handlers for nodes.\n */\nexport const handlers = {\n  blockquote,\n  break: hardBreak,\n  code,\n  delete: strikethrough,\n  emphasis,\n  footnoteReference,\n  footnote,\n  heading,\n  html,\n  imageReference,\n  image,\n  inlineCode,\n  linkReference,\n  link,\n  listItem,\n  list,\n  paragraph,\n  root,\n  strong,\n  table,\n  tableCell,\n  tableRow,\n  text,\n  thematicBreak,\n  toml: ignore,\n  yaml: ignore,\n  definition: ignore,\n  footnoteDefinition: ignore\n}\n\n// Return nothing for nodes that are ignored.\nfunction ignore() {\n  // To do: next major: return `undefined`.\n  return null\n}\n","/**\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef NodeLike\n * @property {PositionLike | null | undefined} [position]\n */\n\n/**\n * Check if `node` is generated.\n *\n * @param {NodeLike | null | undefined} [node]\n *   Node to check.\n * @returns {boolean}\n *   Whether `node` is generated (does not have positional info).\n */\nexport function generated(node) {\n  return (\n    !node ||\n    !node.position ||\n    !node.position.start ||\n    !node.position.start.line ||\n    !node.position.start.column ||\n    !node.position.end ||\n    !node.position.end.line ||\n    !node.position.end.column\n  )\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Definition} Definition\n */\n\n/**\n * @typedef {Root | Content} Node\n *\n * @callback GetDefinition\n *   Get a definition by identifier.\n * @param {string | null | undefined} [identifier]\n *   Identifier of definition.\n * @returns {Definition | null}\n *   Definition corresponding to `identifier` or `null`.\n */\n\nimport {visit} from 'unist-util-visit'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Find definitions in `tree`.\n *\n * Uses CommonMark precedence, which means that earlier definitions are\n * preferred over duplicate later definitions.\n *\n * @param {Node} tree\n *   Tree to check.\n * @returns {GetDefinition}\n *   Getter.\n */\nexport function definitions(tree) {\n  /** @type {Record<string, Definition>} */\n  const cache = Object.create(null)\n\n  if (!tree || !tree.type) {\n    throw new Error('mdast-util-definitions expected node')\n  }\n\n  visit(tree, 'definition', (definition) => {\n    const id = clean(definition.identifier)\n    if (id && !own.call(cache, id)) {\n      cache[id] = definition\n    }\n  })\n\n  return definition\n\n  /** @type {GetDefinition} */\n  function definition(identifier) {\n    const id = clean(identifier)\n    // To do: next major: return `undefined` when not found.\n    return id && own.call(cache, id) ? cache[id] : null\n  }\n}\n\n/**\n * @param {string | null | undefined} [value]\n * @returns {string}\n */\nfunction clean(value) {\n  return String(value || '').toUpperCase()\n}\n","/**\n * @typedef {import('hast').Content} HastContent\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Content} MdastContent\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Parent} MdastParent\n * @typedef {import('mdast').Root} MdastRoot\n */\n\n/**\n * @typedef {HastRoot | HastContent} HastNodes\n * @typedef {MdastRoot | MdastContent} MdastNodes\n * @typedef {Extract<MdastNodes, MdastParent>} MdastParents\n *\n * @typedef EmbeddedHastFields\n *   hast fields.\n * @property {string | null | undefined} [hName]\n *   Generate a specific element with this tag name instead.\n * @property {HastProperties | null | undefined} [hProperties]\n *   Generate an element with these properties instead.\n * @property {Array<HastElementContent> | null | undefined} [hChildren]\n *   Generate an element with this content instead.\n *\n * @typedef {Record<string, unknown> & EmbeddedHastFields} MdastData\n *   mdast data with embedded hast fields.\n *\n * @typedef {MdastNodes & {data?: MdastData | null | undefined}} MdastNodeWithData\n *   mdast node with embedded hast data.\n *\n * @typedef PointLike\n *   Point-like value.\n * @property {number | null | undefined} [line]\n *   Line.\n * @property {number | null | undefined} [column]\n *   Column.\n * @property {number | null | undefined} [offset]\n *   Offset.\n *\n * @typedef PositionLike\n *   Position-like value.\n * @property {PointLike | null | undefined} [start]\n *   Point-like value.\n * @property {PointLike | null | undefined} [end]\n *   Point-like value.\n *\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | null | undefined} parent\n *   Parent of `node`.\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n *   hast node.\n *\n * @callback HFunctionProps\n *   Signature of `state` for when props are passed.\n * @param {MdastNodes | PositionLike | null | undefined} node\n *   mdast node or unist position.\n * @param {string} tagName\n *   HTML tag name.\n * @param {HastProperties} props\n *   Properties.\n * @param {Array<HastElementContent> | null | undefined} [children]\n *   hast content.\n * @returns {HastElement}\n *   Compiled element.\n *\n * @callback HFunctionNoProps\n *   Signature of `state` for when no props are passed.\n * @param {MdastNodes | PositionLike | null | undefined} node\n *   mdast node or unist position.\n * @param {string} tagName\n *   HTML tag name.\n * @param {Array<HastElementContent> | null | undefined} [children]\n *   hast content.\n * @returns {HastElement}\n *   Compiled element.\n *\n * @typedef HFields\n *   Info on `state`.\n * @property {boolean} dangerous\n *   Whether HTML is allowed.\n * @property {string} clobberPrefix\n *   Prefix to use to prevent DOM clobbering.\n * @property {string} footnoteLabel\n *   Label to use to introduce the footnote section.\n * @property {string} footnoteLabelTagName\n *   HTML used for the footnote label.\n * @property {HastProperties} footnoteLabelProperties\n *   Properties on the HTML tag used for the footnote label.\n * @property {string} footnoteBackLabel\n *   Label to use from backreferences back to their footnote call.\n * @property {(identifier: string) => MdastDefinition | null} definition\n *   Definition cache.\n * @property {Record<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Record<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {Handler} unknownHandler\n *   Handler for any none not in `passThrough` or otherwise handled.\n * @property {(from: MdastNodes, node: HastNodes) => void} patch\n *   Copy a node’s positional info.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => Type | HastElement} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {(node: MdastNodes, parent: MdastParents | null | undefined) => HastElementContent | Array<HastElementContent> | null | undefined} one\n *   Transform an mdast node to hast.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastContent>(nodes: Array<Type>, loose?: boolean | null | undefined) => Array<Type | HastText>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n * @property {(left: MdastNodeWithData | PositionLike | null | undefined, right: HastElementContent) => HastElementContent} augment\n *   Like `state` but lower-level and usable on non-elements.\n *   Deprecated: use `patch` and `applyData`.\n * @property {Array<string>} passThrough\n *   List of node types to pass through untouched (except for their children).\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree.\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` attribute on footnotes to prevent it from\n *   *clobbering*.\n * @property {string | null | undefined} [footnoteBackLabel='Back to content']\n *   Label to use from backreferences back to their footnote call (affects\n *   screen readers).\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Label to use for the footnotes section (affects screen readers).\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (note that `id: 'footnote-label'`\n *   is always added as footnote calls use it with `aria-describedby` to\n *   provide an accessible label).\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   Tag name to use for the footnote label.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes.\n * @property {Array<string> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes.\n *\n * @typedef {Record<string, Handler>} Handlers\n *   Handle nodes.\n *\n * @typedef {HFunctionProps & HFunctionNoProps & HFields} State\n *   Info passed around.\n */\n\nimport {visit} from 'unist-util-visit'\nimport {position, pointStart, pointEnd} from 'unist-util-position'\nimport {generated} from 'unist-util-generated'\nimport {definitions} from 'mdast-util-definitions'\nimport {handlers} from './handlers/index.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create `state` from an mdast tree.\n *\n * @param {MdastNodes} tree\n *   mdast node to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {State}\n *   `state` function.\n */\nexport function createState(tree, options) {\n  const settings = options || {}\n  const dangerous = settings.allowDangerousHtml || false\n  /** @type {Record<string, MdastFootnoteDefinition>} */\n  const footnoteById = {}\n\n  // To do: next major: add `options` to state, remove:\n  // `dangerous`, `clobberPrefix`, `footnoteLabel`, `footnoteLabelTagName`,\n  // `footnoteLabelProperties`, `footnoteBackLabel`, `passThrough`,\n  // `unknownHandler`.\n\n  // To do: next major: move to `state.options.allowDangerousHtml`.\n  state.dangerous = dangerous\n  // To do: next major: move to `state.options`.\n  state.clobberPrefix =\n    settings.clobberPrefix === undefined || settings.clobberPrefix === null\n      ? 'user-content-'\n      : settings.clobberPrefix\n  // To do: next major: move to `state.options`.\n  state.footnoteLabel = settings.footnoteLabel || 'Footnotes'\n  // To do: next major: move to `state.options`.\n  state.footnoteLabelTagName = settings.footnoteLabelTagName || 'h2'\n  // To do: next major: move to `state.options`.\n  state.footnoteLabelProperties = settings.footnoteLabelProperties || {\n    className: ['sr-only']\n  }\n  // To do: next major: move to `state.options`.\n  state.footnoteBackLabel = settings.footnoteBackLabel || 'Back to content'\n  // To do: next major: move to `state.options`.\n  state.unknownHandler = settings.unknownHandler\n  // To do: next major: move to `state.options`.\n  state.passThrough = settings.passThrough\n\n  state.handlers = {...handlers, ...settings.handlers}\n\n  // To do: next major: replace utility with `definitionById` object, so we\n  // only walk once (as we need footnotes too).\n  state.definition = definitions(tree)\n  state.footnoteById = footnoteById\n  /** @type {Array<string>} */\n  state.footnoteOrder = []\n  /** @type {Record<string, number>} */\n  state.footnoteCounts = {}\n\n  state.patch = patch\n  state.applyData = applyData\n  state.one = oneBound\n  state.all = allBound\n  state.wrap = wrap\n  // To do: next major: remove `augment`.\n  state.augment = augment\n\n  visit(tree, 'footnoteDefinition', (definition) => {\n    const id = String(definition.identifier).toUpperCase()\n\n    // Mimick CM behavior of link definitions.\n    // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8290999/index.js#L26>.\n    if (!own.call(footnoteById, id)) {\n      footnoteById[id] = definition\n    }\n  })\n\n  // @ts-expect-error Hush, it’s fine!\n  return state\n\n  /**\n   * Finalise the created `right`, a hast node, from `left`, an mdast node.\n   *\n   * @param {MdastNodeWithData | PositionLike | null | undefined} left\n   * @param {HastElementContent} right\n   * @returns {HastElementContent}\n   */\n  /* c8 ignore start */\n  // To do: next major: remove.\n  function augment(left, right) {\n    // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n    if (left && 'data' in left && left.data) {\n      /** @type {MdastData} */\n      const data = left.data\n\n      if (data.hName) {\n        if (right.type !== 'element') {\n          right = {\n            type: 'element',\n            tagName: '',\n            properties: {},\n            children: []\n          }\n        }\n\n        right.tagName = data.hName\n      }\n\n      if (right.type === 'element' && data.hProperties) {\n        right.properties = {...right.properties, ...data.hProperties}\n      }\n\n      if ('children' in right && right.children && data.hChildren) {\n        right.children = data.hChildren\n      }\n    }\n\n    if (left) {\n      const ctx = 'type' in left ? left : {position: left}\n\n      if (!generated(ctx)) {\n        // @ts-expect-error: fine.\n        right.position = {start: pointStart(ctx), end: pointEnd(ctx)}\n      }\n    }\n\n    return right\n  }\n  /* c8 ignore stop */\n\n  /**\n   * Create an element for `node`.\n   *\n   * @type {HFunctionProps}\n   */\n  /* c8 ignore start */\n  // To do: next major: remove.\n  function state(node, tagName, props, children) {\n    if (Array.isArray(props)) {\n      children = props\n      props = {}\n    }\n\n    // @ts-expect-error augmenting an element yields an element.\n    return augment(node, {\n      type: 'element',\n      tagName,\n      properties: props || {},\n      children: children || []\n    })\n  }\n  /* c8 ignore stop */\n\n  /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | null | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n   *   Resulting hast node.\n   */\n  function oneBound(node, parent) {\n    // @ts-expect-error: that’s a state :)\n    return one(state, node, parent)\n  }\n\n  /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */\n  function allBound(parent) {\n    // @ts-expect-error: that’s a state :)\n    return all(state, parent)\n  }\n}\n\n/**\n * Copy a node’s positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {void}\n *   Nothing.\n */\nfunction patch(from, to) {\n  if (from.position) to.position = position(from)\n}\n\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {Type | HastElement}\n *   Nothing.\n */\nfunction applyData(from, to) {\n  /** @type {Type | HastElement} */\n  let result = to\n\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n  if (from && from.data) {\n    const hName = from.data.hName\n    const hChildren = from.data.hChildren\n    const hProperties = from.data.hProperties\n\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName\n      }\n      // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent is likely to keep the content around (otherwise: pass\n      // `hChildren`).\n      else {\n        result = {\n          type: 'element',\n          tagName: hName,\n          properties: {},\n          children: []\n        }\n\n        // To do: next major: take the children from the `root`, or inject the\n        // raw/text/comment or so into the element?\n        // if ('children' in node) {\n        //   // @ts-expect-error: assume `children` are allowed in elements.\n        //   result.children = node.children\n        // } else {\n        //   // @ts-expect-error: assume `node` is allowed in elements.\n        //   result.children.push(node)\n        // }\n      }\n    }\n\n    if (result.type === 'element' && hProperties) {\n      result.properties = {...result.properties, ...hProperties}\n    }\n\n    if (\n      'children' in result &&\n      result.children &&\n      hChildren !== null &&\n      hChildren !== undefined\n    ) {\n      // @ts-expect-error: assume valid children are defined.\n      result.children = hChildren\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform an mdast node into a hast node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   mdast node.\n * @param {MdastParents | null | undefined} [parent]\n *   Parent of `node`.\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n *   Resulting hast node.\n */\n// To do: next major: do not expose, keep bound.\nexport function one(state, node, parent) {\n  const type = node && node.type\n\n  // Fail on non-nodes.\n  if (!type) {\n    throw new Error('Expected node, got `' + node + '`')\n  }\n\n  if (own.call(state.handlers, type)) {\n    return state.handlers[type](state, node, parent)\n  }\n\n  if (state.passThrough && state.passThrough.includes(type)) {\n    // To do: next major: deep clone.\n    // @ts-expect-error: types of passed through nodes are expected to be added manually.\n    return 'children' in node ? {...node, children: all(state, node)} : node\n  }\n\n  if (state.unknownHandler) {\n    return state.unknownHandler(state, node, parent)\n  }\n\n  return defaultUnknownHandler(state, node)\n}\n\n/**\n * Transform the children of an mdast node into hast nodes.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} parent\n *   mdast node to compile\n * @returns {Array<HastElementContent>}\n *   Resulting hast nodes.\n */\n// To do: next major: do not expose, keep bound.\nexport function all(state, parent) {\n  /** @type {Array<HastElementContent>} */\n  const values = []\n\n  if ('children' in parent) {\n    const nodes = parent.children\n    let index = -1\n    while (++index < nodes.length) {\n      const result = one(state, nodes[index], parent)\n\n      // To do: see if we van clean this? Can we merge texts?\n      if (result) {\n        if (index && nodes[index - 1].type === 'break') {\n          if (!Array.isArray(result) && result.type === 'text') {\n            result.value = result.value.replace(/^\\s+/, '')\n          }\n\n          if (!Array.isArray(result) && result.type === 'element') {\n            const head = result.children[0]\n\n            if (head && head.type === 'text') {\n              head.value = head.value.replace(/^\\s+/, '')\n            }\n          }\n        }\n\n        if (Array.isArray(result)) {\n          values.push(...result)\n        } else {\n          values.push(result)\n        }\n      }\n    }\n  }\n\n  return values\n}\n\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastText | HastElement}\n *   Resulting hast node.\n */\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {}\n  /** @type {HastText | HastElement} */\n  const result =\n    'value' in node &&\n    !(own.call(data, 'hProperties') || own.call(data, 'hChildren'))\n      ? {type: 'text', value: node.value}\n      : {\n          type: 'element',\n          tagName: 'div',\n          properties: {},\n          children: all(state, node)\n        }\n\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * Wrap `nodes` with line endings between each node.\n *\n * @template {HastContent} Type\n *   Node type.\n * @param {Array<Type>} nodes\n *   List of nodes to wrap.\n * @param {boolean | null | undefined} [loose=false]\n *   Whether to add line endings at start and end.\n * @returns {Array<Type | HastText>}\n *   Wrapped nodes.\n */\nexport function wrap(nodes, loose) {\n  /** @type {Array<Type | HastText>} */\n  const result = []\n  let index = -1\n\n  if (loose) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  while (++index < nodes.length) {\n    if (index) result.push({type: 'text', value: '\\n'})\n    result.push(nodes[index])\n  }\n\n  if (loose && nodes.length > 0) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  return result\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('./state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Generate a hast footer for called footnote definitions.\n *\n * @param {State} state\n *   Info passed around.\n * @returns {Element | undefined}\n *   `section` element or `undefined`.\n */\nexport function footer(state) {\n  /** @type {Array<ElementContent>} */\n  const listItems = []\n  let index = -1\n\n  while (++index < state.footnoteOrder.length) {\n    const def = state.footnoteById[state.footnoteOrder[index]]\n\n    if (!def) {\n      continue\n    }\n\n    const content = state.all(def)\n    const id = String(def.identifier).toUpperCase()\n    const safeId = normalizeUri(id.toLowerCase())\n    let referenceIndex = 0\n    /** @type {Array<ElementContent>} */\n    const backReferences = []\n\n    while (++referenceIndex <= state.footnoteCounts[id]) {\n      /** @type {Element} */\n      const backReference = {\n        type: 'element',\n        tagName: 'a',\n        properties: {\n          href:\n            '#' +\n            state.clobberPrefix +\n            'fnref-' +\n            safeId +\n            (referenceIndex > 1 ? '-' + referenceIndex : ''),\n          dataFootnoteBackref: true,\n          className: ['data-footnote-backref'],\n          ariaLabel: state.footnoteBackLabel\n        },\n        children: [{type: 'text', value: '↩'}]\n      }\n\n      if (referenceIndex > 1) {\n        backReference.children.push({\n          type: 'element',\n          tagName: 'sup',\n          children: [{type: 'text', value: String(referenceIndex)}]\n        })\n      }\n\n      if (backReferences.length > 0) {\n        backReferences.push({type: 'text', value: ' '})\n      }\n\n      backReferences.push(backReference)\n    }\n\n    const tail = content[content.length - 1]\n\n    if (tail && tail.type === 'element' && tail.tagName === 'p') {\n      const tailTail = tail.children[tail.children.length - 1]\n      if (tailTail && tailTail.type === 'text') {\n        tailTail.value += ' '\n      } else {\n        tail.children.push({type: 'text', value: ' '})\n      }\n\n      tail.children.push(...backReferences)\n    } else {\n      content.push(...backReferences)\n    }\n\n    /** @type {Element} */\n    const listItem = {\n      type: 'element',\n      tagName: 'li',\n      properties: {id: state.clobberPrefix + 'fn-' + safeId},\n      children: state.wrap(content, true)\n    }\n\n    state.patch(def, listItem)\n\n    listItems.push(listItem)\n  }\n\n  if (listItems.length === 0) {\n    return\n  }\n\n  return {\n    type: 'element',\n    tagName: 'section',\n    properties: {dataFootnotes: true, className: ['footnotes']},\n    children: [\n      {\n        type: 'element',\n        tagName: state.footnoteLabelTagName,\n        properties: {\n          // To do: use structured clone.\n          ...JSON.parse(JSON.stringify(state.footnoteLabelProperties)),\n          id: 'footnote-label'\n        },\n        children: [{type: 'text', value: state.footnoteLabel}]\n      },\n      {type: 'text', value: '\\n'},\n      {\n        type: 'element',\n        tagName: 'ol',\n        properties: {},\n        children: state.wrap(listItems, true)\n      },\n      {type: 'text', value: '\\n'}\n    ]\n  }\n}\n","/**\n * @typedef {import('hast').Content} HastContent\n * @typedef {import('hast').Root} HastRoot\n *\n * @typedef {import('mdast').Content} MdastContent\n * @typedef {import('mdast').Root} MdastRoot\n *\n * @typedef {import('./state.js').Options} Options\n */\n\n/**\n * @typedef {HastRoot | HastContent} HastNodes\n * @typedef {MdastRoot | MdastContent} MdastNodes\n */\n\nimport {footer} from './footer.js'\nimport {createState} from './state.js'\n\n/**\n * Transform mdast to hast.\n *\n * ##### Notes\n *\n * ###### HTML\n *\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\n * as semistandard `raw` nodes.\n * Most utilities ignore `raw` nodes but two notable ones don’t:\n *\n * *   `hast-util-to-html` also has an option `allowDangerousHtml` which will\n *     output the raw HTML.\n *     This is typically discouraged as noted by the option name but is useful\n *     if you completely trust authors\n * *   `hast-util-raw` can handle the raw embedded HTML strings by parsing them\n *     into standard hast nodes (`element`, `text`, etc).\n *     This is a heavy task as it needs a full HTML parser, but it is the only\n *     way to support untrusted content\n *\n * ###### Footnotes\n *\n * Many options supported here relate to footnotes.\n * Footnotes are not specified by CommonMark, which we follow by default.\n * They are supported by GitHub, so footnotes can be enabled in markdown with\n * `mdast-util-gfm`.\n *\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\n * that explains footnotes, which is hidden for sighted users but shown to\n * assistive technology.\n * When your page is not in English, you must define translated values.\n *\n * Back references use ARIA attributes, but the section label itself uses a\n * heading that is hidden with an `sr-only` class.\n * To show it to sighted users, define different attributes in\n * `footnoteLabelProperties`.\n *\n * ###### Clobbering\n *\n * Footnotes introduces a problem, as it links footnote calls to footnote\n * definitions on the page through `id` attributes generated from user content,\n * which results in DOM clobbering.\n *\n * DOM clobbering is this:\n *\n * ```html\n * <p id=x></p>\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n * ```\n *\n * Elements by their ID are made available by browsers on the `window` object,\n * which is a security risk.\n * Using a prefix solves this problem.\n *\n * More information on how to handle clobbering and the prefix is explained in\n * Example: headings (DOM clobbering) in `rehype-sanitize`.\n *\n * ###### Unknown nodes\n *\n * Unknown nodes are nodes with a type that isn’t in `handlers` or `passThrough`.\n * The default behavior for unknown nodes is:\n *\n * *   when the node has a `value` (and doesn’t have `data.hName`,\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\n *     node\n * *   otherwise, create a `<div>` element (which could be changed with\n *     `data.hName`), with its children mapped from mdast to hast as well\n *\n * This behavior can be changed by passing an `unknownHandler`.\n *\n * @param {MdastNodes} tree\n *   mdast tree.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {HastNodes | null | undefined}\n *   hast tree.\n */\n// To do: next major: always return a single `root`.\nexport function toHast(tree, options) {\n  const state = createState(tree, options)\n  const node = state.one(tree, null)\n  const foot = footer(state)\n\n  if (foot) {\n    // @ts-expect-error If there’s a footer, there were definitions, meaning block\n    // content.\n    // So assume `node` is a parent node.\n    node.children.push({type: 'text', value: '\\n'}, foot)\n  }\n\n  // To do: next major: always return root?\n  return Array.isArray(node) ? {type: 'root', children: node} : node\n}\n","/**\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('mdast-util-to-hast').Options} Options\n * @typedef {import('unified').Processor<any, any, any, any>} Processor\n *\n * @typedef {import('mdast-util-to-hast')} DoNotTouchAsThisImportIncludesRawInTree\n */\n\nimport {toHast} from 'mdast-util-to-hast'\n\n// Note: the `<MdastRoot, HastRoot>` overload doesn’t seem to work :'(\n\n/**\n * Plugin that turns markdown into HTML to support rehype.\n *\n * *   If a destination processor is given, that processor runs with a new HTML\n *     (hast) tree (bridge-mode).\n *     As the given processor runs with a hast tree, and rehype plugins support\n *     hast, that means rehype plugins can be used with the given processor.\n *     The hast tree is discarded in the end.\n *     It’s highly unlikely that you want to do this.\n * *   The common case is to not pass a destination processor, in which case the\n *     current processor continues running with a new HTML (hast) tree\n *     (mutate-mode).\n *     As the current processor continues with a hast tree, and rehype plugins\n *     support hast, that means rehype plugins can be used after\n *     `remark-rehype`.\n *     It’s likely that this is what you want to do.\n *\n * @param destination\n *   Optional unified processor.\n * @param options\n *   Options passed to `mdast-util-to-hast`.\n */\nconst remarkRehype =\n  /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */\n  (\n    function (destination, options) {\n      return destination && 'run' in destination\n        ? bridge(destination, options)\n        : mutate(destination || options)\n    }\n  )\n\nexport default remarkRehype\n\n/**\n * Bridge-mode.\n * Runs the destination with the new hast tree.\n *\n * @type {import('unified').Plugin<[Processor, Options?], MdastRoot>}\n */\nfunction bridge(destination, options) {\n  return (node, file, next) => {\n    destination.run(toHast(node, options), file, (error) => {\n      next(error)\n    })\n  }\n}\n\n/**\n * Mutate-mode.\n * Further plugins run on the hast tree.\n *\n * @type {import('unified').Plugin<[Options?]|void[], MdastRoot, HastRoot>}\n */\nfunction mutate(options) {\n  // @ts-expect-error: assume a corresponding node is returned by `toHast`.\n  return (node) => toHast(node, options)\n}\n"],"names":["normalizeUri","value","result","index","start","skip","code","replace","asciiAlphanumeric","next","blockquote","state","node","hardBreak","lang","properties","strikethrough","emphasis","footnoteReference","id","safeId","counter","reuseCounter","link","sup","footnote","footnoteById","no","identifier","heading","html","revert","subtype","suffix","contents","head","tail","imageReference","def","image","inlineCode","text","linkReference","listItem","parent","results","loose","listLoose","listItemLoose","children","paragraph","child","spread","list","root","strong","pointStart","point","pointEnd","position","type","table","rows","firstRow","tableContent","body","end","tableRow","siblings","tagName","align","length","cellIndex","cells","cell","alignValue","tableCell","tab","space","trimLines","source","search","match","last","lines","trimLine","startIndex","endIndex","thematicBreak","handlers","ignore","generated","own","definitions","tree","cache","visit","definition","clean","createState","options","settings","dangerous","patch","applyData","oneBound","allBound","wrap","augment","left","right","data","ctx","props","one","all","from","to","hName","hChildren","hProperties","defaultUnknownHandler","values","nodes","footer","listItems","content","referenceIndex","backReferences","backReference","tailTail","toHast","foot","remarkRehype","destination","bridge","mutate","remarkRehype$1","file","error"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34]}